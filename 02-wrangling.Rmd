# Cleaning and wrangling data {#wrangling}

## Overview 

This chapter will be centered around tools for cleaning and wrangling data to move data from its raw format into a format that is suitable for data analysis. This will be in the context of a real world Data Science application and we will continue to practice working through a whole case study.

## Chapter learning objectives
By the end of the chapter, students will be able to:

* define the term "tidy data"
* discuss the advantages and disadvantages from storing data in a tidy data format
* recall and use the following tidyverse functions and operators for their intended data wrangling tasks:
    - `select`
    - `filter`
    - `%>%`
    - `map`
    - `mutate`
    - `summarise`
    - `group_by`
    - `gather`
    - `separate`
    - `%in%`

## Vectors and Data frames

At this point, we know how to load data into R from various file formats. Once loaded into R, all the tools we have learned about for reading data into R represent the data as a data frame. So now, we will spend some time learning more about data frames in R and what they are made up of so that we have a better understanding of how we can use and manipulate these objects.

### What is a data frame?

Let's first start by defining exactly what a data frame is. From a data perspective, it is a rectangle where the rows are the observations.

<img src="img/obs.jpeg" width="650">

And the columns are the variables:

<img src="img/vars.jpeg" width="650">


From a computer programming perspective, in R, a data frame is a special sub-type of a list object whose elements (columns) are vectors. In the data frame below, the data frame has 3 elements that are vectors whose names are `state`, `year` and `population`.

<img src="img/vectors.jpeg" width="650">

### What is a vector?

In R, vectors are objects that can contain 1 or more elements. The vector elements are ordered, and they must all be of the same type. Common example types of vectors are character (e.g., letter or words), numeric (whole numbers and fractions) and logical (e.g., `TRUE` or `FALSE`). In the vector shown below the elements are of numeric type:

<img src="img/vector.jpeg" width="600">

### How are vectors different from a list?

Lists are also objects in R that have multiple elements. Vectors and lists differ by the requirement of element type consistency. All elements within a single vector must be of the same type (e.g., all elements are numbers), whereas elements within a single list can be of different types (e.g., characters, numbersl logicals and even other lists can be elements in the same list).

<img src="img/vec_vs_list.jpeg" width="600">

### What does this have to do with data frames?

As mentioned earlier, data frames are really a special type of list objects where the elements are only vectors. Representing data with such an object as this allow us to easily work with our data in a rectangular/spreadsheet like manner. This allows us have columns/vectors of different characteristics associated/linked in one object. This is similar to a table in a spreadsheet or a database.

<img src="img/dataframe.jpeg" width="650">

## Tidy Data

There are many ways a spreadsheet-like dataset can be organized. In this chapter we are going to focus on the tidy data format of organization, and how to make your raw (and likely messy) data tidy. This is because a variety of tools we would like to be able to use in R are designed to work most effectively (and efficiently) with tidy data. 

### What is tidy data?

A tidy data is one that is satisfied by these three criteria:

- each row is a single observation,
- each variable is a single column, and
- each value is a single cell (i.e., its row, column position in the data frame is not shared with another value)

![](https://d33wubrfki0l68.cloudfront.net/6f1ddb544fc5c69a2478e444ab8112fb0eea23f8/91adc/images/tidy-1.png)
*image source: [R for Data Science](https://r4ds.had.co.nz/) by Garrett Grolemund & Hadley Wickham*

> **Definitions to know!**
>
> observation -  quantities or a qualities we collect from a given entity/object 
>
> variable - any characteristics, number, or quantity that can be measured or counted 
>
> value - a single collected quantity or a quality from a given entity/object

### Why is tidy data important in R?

First, there are many well designed `tidyverse` data cleaning/wrangling tools to help you easily get your data tidy data. Second, one of the most popular plotting tools in R, the `ggplot2` functions, expect data in tidy format. Third most statistical analysis functions expect data in tidy format. Given that all of these tasks are central features to virtually any data analysis project it is well worth spending the time to get your data into a tidy format up front. Now let's explore how we can do this in R.

### Going from wide to long (or tidy!) using `gather`

One common thing that often has to be done to get data into a tidy format is to gather columns so that each row is a single observation and each column is a single variable. Often times data does not come this way, as although tidy data is a better organization structure for data analysis, it is not as intuitive of a data organization structure for human readability and understanding.

For example, the we read in data below is not in tidy format, but is in a very intuitive format for human understanding:

```{r 02-tidyverse, warning=FALSE, message=FALSE}
library(tidyverse)
hist_vote_wide <- read_csv("data/historical_vote_wide.csv")
hist_vote_wide
```

What is wrong with our untidy format above? From a data analysis perspective, this format is not ideal because in this format the outcome of the variable "result" (winner or runner up) is stored as column names and not easily accessible for the data analysis functions we will want to apply to our data set. Additionally, the values of the "candidate" variable are spread across two columns and will require some sort of binding or joining to get them into one single column to allow us to do our desired visualization and statistical tasks later on.

To accomplish this data tranformation we will use the `tidyverse` function `gather`. To use gather we need to specify:

1. the dataset

2. the key which is the name of a new column that will be created and whose values will come from names of the columns that we want to combine (here `result`)

3. the value which is the name of a new column that will be created and whose values will come from the values of the columns we want to combine (here `value`)

4. the names of the columns that we want to combine  (we list these after specifying the key and value and separate the column names with commas)

For our example we would use gather to combine the winner and runnerup columns into a single column called candidate, and create a column called result that contains the outcome of the election for each candidate:

```{r}
hist_vote_tidy <- gather(hist_vote_wide, 
                         key = result, 
                         value = candidate, 
                         winner, runnerup)
hist_vote_tidy
```

> *Note: In the code above, the call to the `gather` function is split across several lines.*
> *This is allowed and encouraged when programming in R when your code line exceeds 80*
> *characters. When doing this, it is important to end the line with a comma `,` so that R*
> *knows the function should continue to the next line.*

The data above is now tidy because all 3 criteria for tidy data have now been met:

1. All the variables (`candidate` and `result`) are now their own columns in the data frame. 
2. Each row is a single observation (i.e., each candidate's name and result, the observations, are in a single row for each candidate).
3. Each value is a single cell (i.e., its row, column position in the data frame is not shared with another value).

### Using separate to deal with multiple delimiters

As discussed above, data is also not considered tidy when multiple values are stored in the same cell. We can see that in addition to the previous untidy problem we faced with the earlier version of this data set, the one we show below is even messier because the winner and runnerup columns contain both the candidate's name as well as the party they were a member of. To make this messy data tidy we'll have to fix both of these issues.

```{r, warning=FALSE, message=FALSE}
hist_vote_party <- read_csv("data/historical_vote_messy.csv")
hist_vote_party
```

First we'll use gather to create the result and candidate column as we did previously:

```{r}
hist_vote_party_gathered <- gather(hist_vote_party, 
                          key = result, 
                          value = candidate, 
                          winner, runnerup)
hist_vote_party_gathered
```

And then we separate to split the candidate column into two columns, one called candidate that now contains only the candidate's name, and called party that contains a short identifier for which political party the candidate belonged to:

```{r}
hist_vote_party_tidy <- separate(hist_vote_party_gathered,
                                 col = candidate, 
                                 into = c("candidate", "party"), 
                                 sep = "/") 
hist_vote_party_tidy
```

Is this data now tidy? Well, if we recall the 3 criteria for tidy data:

- each row is a single observation,
- each variable is a single column, and
- each value is a single cell.

We can see that this data now satifies all 3 criteria ane we can easily do some data analysis, for example visualize the number of winning candidates for each party over this time span:

```{r candidate_count, fig.height=4, fig.width=5}
ggplot(hist_vote_party_tidy, aes(x = result, fill = party)) +
  geom_bar(position=position_dodge()) +
  scale_fill_manual(values=c("blue", "red")) +
  xlab("US Presidential election result") +
  ylab("Number of US Presidential candidates") +
  ggtitle("US Presidential candidates (1980 - 2016)") 

```

From this visualization we can see that between 1980 - 2016 (inclusive) the Republican party have had more winning US Presidential election candidates than the Democratic party has.

## Combining functions using the pipe operator, `%>%`:

Now we will learn about an efficient way to combine functions in R; the pipe operator: `%>%`. You can think of the pipe as a physical pipe - taking the output from the function on the left-handside of the pipe and passing it as the input to first argument to the function on the right-handside of the pipe. Let's look at some examples of this.

### Using `%>%` to combine `filter` and `select`

Remembering our the US state-level property, income, population, and voting data that we explored in chapter 1: 
```{r, warning=FALSE, message=FALSE}
us_data <- read_csv("data/state_property_vote.csv")
us_data
```

If we would like to subset the data to obtain only the values for median income and median property value for the state of California ("CA"), we can use the functions `filter()` and `select()` to do this. First we use `filter()` to create a data frame object called `ca_prop_data` that only contains the values for the state of California. We can then use `select()` on this data frame to subset the values for median income and median property value for California:

```{r}
ca_prop_data <- filter(us_data, state == "CA")
ca_inc_prop <- select(ca_prop_data, med_income, med_prop_val)
ca_inc_prop
```

Although this is a valid approach, there is a more efficient and readable approach we could take by using the pipe, `%>%`. With the pipe, we do not need to create an intermediate object to store the output from `filter()`, instead we can use the pipe to directly send the output of `filter()` to the input of `select()`:

```{r}
ca_inc_prop <- filter(us_data, state == "CA") %>% select(med_income, med_prop_val)
ca_inc_prop
```

But wait? Why does our `select()` function call look different in these two examples? Well, when you use the pipe, the output of the function on the left is automatically provided as the value for the first argument for the function on the right, and thus you do not specify the value for that argument in that function call. In this case that would be the data frame that we would be `select`-ing from.

As you can see, both of these approaches give us the same output but the second approach is more efficient and readable.

### Using `%>%` with more than two functions

The `%>%` can be used with any function in R. Additionally, we can pipe together more than two functions. In this example, we will pipe together 3 functions to order the states by commute time for states whose population is less than 1 million people:

```{r}
small_state_commutes <- filter(us_data, population < 1000000) %>% 
  select(state, mean_commute_minutes) %>% 
  arrange(mean_commute_minutes)
small_state_commutes
```

> Note 1: `arrange` is a function that takes the name of a data frame and column(s) to order it by and returns a data frame where the rows are ordered by that column in ascening order. Here we used only one column for sorting (`mean_commute_minutes`) but more than one can also be used. To do this, list additional columns separated by commas. The order they are listed in indicates the order that they should be sorted in.
>
> Note 2: You might also have noticed that we split the function calls across lines after the pipe, similar as to when we did this earlier in the chapter for long function calls. Again the is allowed and recommeded, especially when there are more than 80 characters in the piped functions. Doing this makes your code more readable. When you do this it is important to have the line breaks occur after the pipe to tell R that your code is continuing onto the next line. 

## Iterating over data with `group_by` + `summarise`

### Calculating summary statistics:

Often times we want to calculate some summary value for the data (we often call this a summary statistic). A useful `dplyr` function for doing this is called `summarise`. Examples of summary statistics we might want to calculate are the number of observations, the average/mean value for a column, a minimum value for a column, *etc*. Below we show how to use the summarize function to calculate the minimum, maximum and mean commute time for all US states:

```{r}
us_commute_time_summary <- summarise(us_data, 
                                  min_mean_commute = min(mean_commute_minutes),
                                  max_mean_commute = max(mean_commute_minutes),
                                  mean_mean_commute = mean(mean_commute_minutes))
us_commute_time_summary
```

### Calculating group summary statistics:

A common pairing with `summarise` is `group_by`. Pairing these functions together can let you summarise values for sub-groups within a data set. For example, here we can use `group_by`split up the data into groups based on which party they voted for in the US election and then calculate the minimum, maximum and mean commute time for each of the groups.

The group by function takes at least two arguments. The first is the data frame that will be grouped, and the second onwards are columns to use in the grouping. Here we use only one column for grouping (`party`) but more than one can also be used. To do this, list additional columns separated by commas. 

```{r}
us_commute_time_summary_by_party <- group_by(us_data, party) %>% 
  summarise(min_mean_commute = min(mean_commute_minutes),
            max_mean_commute = max(mean_commute_minutes),
            mean_mean_commute = mean(mean_commute_minutes))
us_commute_time_summary_by_party
```

## Additional reading on the `dplyr` functions

We haven't explicitly said this yet, but the `tidyverse` is actually a meta R package that installs a collection of R packages that all follow the tidy data philosophy we discussed above. One of the tidyverse packages is `dplyr` - a data wrangling workhorse. You have already met 6 of the dplyr function (`select`, `filter`, `mutate`, `arrange`, `summarise` and `group_by`). To learn more about those six and meet a few more useful ones, read the post at this link: http://stat545.com/block010_dplyr-end-single-table.html#where-were-we


## Using `purrr`'s `map*` functions to iterate

Where should you turn when you discover the next step in your data wrangling/cleaning process requires you to apply a function to each column in a data frame? For example, if you wanted to know the maximum value of each column in a data frame? Well you could use `summarise` as discussed above, but this becomes inconvenient when you have many columns as `summarise` requires you to type out a column name and a data tranformation for each summary statistic that you want to calculate.

In cases like this where you want to apply the same data transformation to all columns it is more efficient to use `purrr`'s `map` function to apply the `max` function to each column. For example, let's do that and find that maximum value of each column of the `mtcars` data frame (a built-in data set that comes with R). First, let's peak at an become familiar with the data:

```{r 02-preview-data}
head(mtcars)
```

Next, we can use `map` to apply the `max` function to each column. `map` takes two arguments, an object (a vector, data frame or list) that you want to apply the function to, and the function that you would like to apply. Here our arguments will be `mtcars` and `max`:

```{r 02-map}
max_of_columns <- map(mtcars, max)
max_of_columns
```

> ##### Note:
> `purrr` is part of the tidyverse, and so like the `dplyr` and `ggplot` functions, once we call `library(tidyverse)` we do not need to separately load the `purrr` package.

Our output looks a bit weird though? We passed in a data frame, but our output doesn't look like a data frame... And that it because it isn't, its a plain vanilla list:

```{r 02-type-out-of-map}
typeof(max_of_columns)
```

So what do we do? Convert this to a data frame? No need, what we should do instead is to use a different `map*` function from the `purrr` package. There are quite a few to choose from, they all work similarly and their name refects the type of output you want from the mapping operation:

| `map` function | Output |
|----------|--------|
| `map()` | list |
| `map_lgl()` | logical vector |
| `map_int()` | integer vector |
| `map_dbl()` | double vector |
| `map_chr()` | character vector |
| `map_df()` | data frame |

So let's get the column maximum's again, but this time use the `map_df` function to return the output as a data frame:

```{r 02-map-df-example}
max_of_columns <- map_df(mtcars, max)
max_of_columns
```

Do we always want to use `map_df`? Nope! It depends what we are trying to do. So before you choose your `map*` function, think about your downstream usage of the output of that function.

What if you need to add other arguments to the functions you want to map? For example, what if there were NA values in our columns that we wanted to know the maximum of? Well then we also need to add the argument `na.rm  = TRUE` to the `max` function so that we get a more useful value than NA returned (remember that is what happens with many of the built-in R statistical functions when NA's are present...). What we need to do in that case is do what is called "creating an anonymous function" within the `map_df` function. We do that in the place where we previously specified our max function. Here we will put the two calls to `map_df` right after each other so you can see the difference:

```
# no additional arguments to the max function 
map_df(mtcars, max)
```
versus
```
# adding the na.rm  = TRUE argument to the max function
map_df(mtcars, function(df) max(df, na.rm  = TRUE))
```

You can see that's quite a bit of extra typing... So the creators of `purrr` have made a shortcut for this because it is so commonly done. In the shortcut we replace `function(VARIABLE)` with a `~` and replace the `VARIABLE` in the function call with a `.`, see the example below:

```
# adding the na.rm  = TRUE argument to the max function using the shortcut 
map_df(mtcars, ~ max(., na.rm  = TRUE))
```

### A bit more about the `map*` functions

The `map` functions are generally quite useful for solving many iteration/repetition problems. It's use does not have to be limited to columns of a data frame. It can be used to apply functions to elements of a vector or list, and even to lists of data frames, or nested data frames.

## Additional readings/resources
- [Data transformation chapter](https://r4ds.had.co.nz/transform.html) from [R for Data Science](https://r4ds.had.co.nz/) by Garrett Grolemund & Hadley Wickham
- [Tidy data chapter](https://r4ds.had.co.nz/tidy-data.html) from [R for Data Science](https://r4ds.had.co.nz/) by Garrett Grolemund & Hadley Wickham
- [The `map` functions](https://r4ds.had.co.nz/iteration.html#the-map-functions) from [R for Data Science](https://r4ds.had.co.nz/) by Garrett Grolemund & Hadley Wickham
