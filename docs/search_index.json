[
["wrangling.html", "Chapter 3 Cleaning and wrangling data 3.1 Overview 3.2 Chapter learning objectives 3.3 Vectors and Data frames 3.4 Tidy Data 3.5 The dplyr functions 3.6 Using purrr’s map* functions to iterate 3.7 Additional readings/resources", " Chapter 3 Cleaning and wrangling data 3.1 Overview This chapter will be centered around tools for cleaning and wrangling data to move data from its raw format into a format that is suitable for data analysis. This will be in the context of a real world Data Science application and we will continue to practice working through a whole case study. 3.2 Chapter learning objectives By the end of the chapter, students will be able to: define the term “tidy data” discuss the advantages and disadvantages from storing data in a tidy data format recall and use the following tidyverse functions and operators for their intended data wrangling tasks: select filter %&gt;% map mutate summarise group_by gather separate %in% 3.3 Vectors and Data frames At this point, we know how to load data into R from various file formats. Once loaded into R, all the tools we have learned about for reading data into R represent the data as a data frame. So now, we will spend some time learning more about data frames in R and what they are made up of so that we have a better understanding of how we can use and manipulate these objects. 3.3.1 What is a data frame? Let’s first start by defining exactly what a data frame is. From a data perspective, it is a rectangle where the rows are the observations. And the columns are the variables: From a computer programming perspective, in R, a data frame is a special sub-type of a list object whose elements (columns) are vectors. In the data frame below, the data frame has 3 elements that are vectors whose names are state, year and population. 3.3.2 What is a vector? In R, vectors are objects that can contain 1 or more elements. The vector elements are ordered, and they must all be of the same type. Common example types of vectors are character (e.g., letter or words), numeric (whole numbers and fractions) and logical (e.g., TRUE or FALSE). In the vector shown below the elements are of numeric type: 3.3.3 How are vectors different from a list? Lists are also objects in R that have multiple elements. Vectors and lists differ by the requirement of element type consistency. All elements within a single vector must be of the same type (e.g., all elements are numbers), whereas elements within a single list can be of different types (e.g., characters, numbersl logicals and even other lists can be elements in the same list). 3.3.4 What does this have to do with data frames? As mentioned earlier, data frames are really a special type of list objects where the elements are only vectors. Representing data with such an object as this allow us to easily work with our data in a rectangular/spreadsheet like manner. This allows us have columns/vectors of different characteristics associated/linked in one object. This is similar to a table in a spreadsheet or a database. 3.4 Tidy Data There are many ways a spreadsheet-like dataset can be organized. In this chapter we are going to focus on the tidy data format of organization, and how to make your messy data tidy. This is because a variety of tools we would like to be able to use in R are designed to work most effectively (and efficiently) with tidy data. 3.4.1 What is tidy data? A tidy data is one that is satified by these three criteria: each row is a single observation, each variable is a single column, and each value is a single cell (i.e., its row, column position in the data frame is not shared with another value) image source: R for Data Science by Garrett Grolemund &amp; Hadley Wickham 3.4.2 Why is tidy data important in R? First, many tidyverse data cleaning/wrangling tools work best with tidy data. Second, one of the most popular plotting tools in R, the ggplot2 functions, expect data in tidy format. Third most statistical analysis functions expect data in tidy format. In contrast to Python and other programming languages, in R you do not need to manually create dummy variables to represent your categorical data for its statistical or machine learning tools. R does this for you under the hood through factorization, but your data must be tidy for this to work. Given that all of these tasks are central features to virtually any data analysis project it is well worth spending the time to get your data into a tidy format up front. Now let’s explore how we can do this in R. 3.4.3 Going from wide to long (or tidy!) using gather One common thing that often has to be done to get data into a tidy format is to gather columns so that each row is a single observation and each column is a single variable. Often times data does not come this way, as although tidy data is a better organization structure for data analysis, it is not as intuitive of a data organization structure for human readability and understanding. For example, the we read in data below is not in tidy format, but is in a very intuitive format for human understanding: library(tidyverse) ## ── Attaching packages ─────────────────────────────────────────────────────── tidyverse 1.2.1 ── ## ✔ ggplot2 3.2.1 ✔ purrr 0.3.2 ## ✔ tibble 2.1.3 ✔ dplyr 0.8.3 ## ✔ tidyr 0.8.3 ✔ stringr 1.4.0 ## ✔ readr 1.3.1 ✔ forcats 0.4.0 ## ── Conflicts ────────────────────────────────────────────────────────── tidyverse_conflicts() ── ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() hist_vote_wide &lt;- read_csv(&quot;historical_vote_wide.csv&quot;) head(hist_vote_wide) # A tibble: 6 x 3 election_year winner runnerup &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 2016 Donald Trump Hillary Clinton 2 2012 Barack Obama Mitt Romney 3 2008 Barack Obama John McCain 4 2004 George Bush John Kerry 5 2000 George Bush Al Gore 6 1996 Bill Clinton Bob Dole What is wrong with our untidy format above? From a data analysis perspective, this format is not idead because in this format the outcome of the variable “result” (winner or runner up) is stored as column names and not easily accessible for the functions we will desire to apply to our data set. Additionally, the values of the “candidate” variable is spread across two columns and will require some sort of binding or joining to get them into one single column to allow us to do our desired visualization and statistical tasks later on. To accomplish this data tranformation we will use the tidyverse function gather. To use gather we need to specify: the dataset the key which is the name of a new column that will be created and whose values will come from names of the columns that we want to combine (here result) the value which is the name of a new column that will be created and whose values will come from the values of the columns we want to combine (here value) the names of the columns that we want to combine (we list these after specifying the key and value and separate the column names with commas) For our example we would use gather to combine the winner and runnerup columns into a single column called candidate, and create a column called result that contains the outcome of the election for each candidate: hist_vote_tidy &lt;- hist_vote_wide %&gt;% gather(key = result, value = candidate, winner, runnerup) print(hist_vote_tidy) # A tibble: 20 x 3 election_year result candidate &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 2016 winner Donald Trump 2 2012 winner Barack Obama 3 2008 winner Barack Obama 4 2004 winner George W Bush 5 2000 winner George W Bush 6 1996 winner Bill Clinton 7 1992 winner Bill Clinton 8 1988 winner George HW Bush 9 1984 winner Ronald Reagan 10 1980 winner Ronald Reagan 11 2016 runnerup Hillary Clinton 12 2012 runnerup Mitt Romney 13 2008 runnerup John McCain 14 2004 runnerup John Kerry 15 2000 runnerup Al Gore 16 1996 runnerup Bob Dole 17 1992 runnerup George HW Bush 18 1988 runnerup Michael Dukakis 19 1984 runnerup Walter Mondale 20 1980 runnerup Jimmy Carter 3.4.4 Using separate to deal with multiple delimiters Data is also not considered tidy when multiple values are stored in the same cell. We can see that in addition to the previous untidy problem we faced with the earlier version of this data set, the one we show below is even messier because the winner and runnerup columns contain both the candidate’s name as well as the party they were a member of. To make this messy data tidy we’ll have to fix both of these issues. hist_vote_messy &lt;- read_csv(&quot;historical_vote_messy.csv&quot;) print(hist_vote_messy) # A tibble: 10 x 3 election_year winner runnerup &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 2016 Donald Trump/Rep Hillary Clinton/Dem 2 2012 Barack Obama/Dem Mitt Romney/Rep 3 2008 Barack Obama/Dem John McCain/Rep 4 2004 George W Bush/Rep John Kerry/Dem 5 2000 George W Bush/Rep Al Gore/Dem 6 1996 Bill Clinton/Dem Bob Dole/Rep 7 1992 Bill Clinton/Dem George HW Bush/Rep 8 1988 George HW Bush/Rep Michael Dukakis/Dem 9 1984 Ronald Reagan/Rep Walter Mondale/Dem 10 1980 Ronald Reagan/Rep Jimmy Carter/Dem First we’ll use gather to create the result and candidate column as we did previously: gather(hist_vote_messy, key = result, value = candidate, winner, runnerup) # A tibble: 20 x 3 election_year result candidate &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 2016 winner Donald Trump/Rep 2 2012 winner Barack Obama/Dem 3 2008 winner Barack Obama/Dem 4 2004 winner George W Bush/Rep 5 2000 winner George W Bush/Rep 6 1996 winner Bill Clinton/Dem 7 1992 winner Bill Clinton/Dem 8 1988 winner George HW Bush/Rep 9 1984 winner Ronald Reagan/Rep 10 1980 winner Ronald Reagan/Rep 11 2016 runnerup Hillary Clinton/Dem 12 2012 runnerup Mitt Romney/Rep 13 2008 runnerup John McCain/Rep 14 2004 runnerup John Kerry/Dem 15 2000 runnerup Al Gore/Dem 16 1996 runnerup Bob Dole/Rep 17 1992 runnerup George HW Bush/Rep 18 1988 runnerup Michael Dukakis/Dem 19 1984 runnerup Walter Mondale/Dem 20 1980 runnerup Jimmy Carter/Dem And then we separate to split the candidate column into two columns, one called candidate that now contains only the candidate’s name, and called party that contains a short identifier for which political party the candidate belonged to: gather(hist_vote_messy, key = result, value = candidate, winner, runnerup) %&gt;% separate(col = candidate, into = c(&quot;candidate&quot;, &quot;party&quot;), sep = &quot;/&quot;) # A tibble: 20 x 4 election_year result candidate party &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 2016 winner Donald Trump Rep 2 2012 winner Barack Obama Dem 3 2008 winner Barack Obama Dem 4 2004 winner George W Bush Rep 5 2000 winner George W Bush Rep 6 1996 winner Bill Clinton Dem 7 1992 winner Bill Clinton Dem 8 1988 winner George HW Bush Rep 9 1984 winner Ronald Reagan Rep 10 1980 winner Ronald Reagan Rep 11 2016 runnerup Hillary Clinton Dem 12 2012 runnerup Mitt Romney Rep 13 2008 runnerup John McCain Rep 14 2004 runnerup John Kerry Dem 15 2000 runnerup Al Gore Dem 16 1996 runnerup Bob Dole Rep 17 1992 runnerup George HW Bush Rep 18 1988 runnerup Michael Dukakis Dem 19 1984 runnerup Walter Mondale Dem 20 1980 runnerup Jimmy Carter Dem 3.5 The dplyr functions We haven’t explicitly said this yet, but the tidyverse is actually a meta R package that installs a collection of R packages that all follow the tidy data philosophy (more on this below). One of the tidyverse packages is dplyr - a data wrangling workhorse. You have already met 3 of the dplyr function (select, filter and mutate). To learn more about those three and meet a few more useful ones, read the post at this link: http://stat545.com/block010_dplyr-end-single-table.html#where-were-we 3.6 Using purrr’s map* functions to iterate Where should you turn when you discover the next step in your data wrangling/cleaning process requires you to apply a function to each column in a data frame? For example, if you wanted to know the maximum value of each column in a data frame, you could use purrr’s map function to apply the max function to each column. For example, let’s do that and find that maximum value of each column of the mtcars data frame (a built-in data set that comes with R). First, let’s peak at an become familiar with the data: head(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 Next, we can use map to apply the max function to each column. map takes two arguments, an object (a vector, data frame or list) that you want to apply the function to, and the function that you would like to apply. Here our arguments will be mtcars and max: max_of_columns &lt;- map(mtcars, max) max_of_columns ## $mpg ## [1] 33.9 ## ## $cyl ## [1] 8 ## ## $disp ## [1] 472 ## ## $hp ## [1] 335 ## ## $drat ## [1] 4.93 ## ## $wt ## [1] 5.424 ## ## $qsec ## [1] 22.9 ## ## $vs ## [1] 1 ## ## $am ## [1] 1 ## ## $gear ## [1] 5 ## ## $carb ## [1] 8 3.6 Note: purrr is part of the tidyverse, and so like the dplyr and ggplot functions, once we call library(tidyverse) we do not need to separately load the purrr package. Our output looks a bit weird though? We passed in a data frame, but our output doesn’t look like a data frame… And that it because it isn’t, its a plain vanilla list: typeof(max_of_columns) ## [1] &quot;list&quot; So what do we do? Convert this to a data frame? No need, what we should do instead is to use a different map* function from the purrr package. There are quite a few to choose from, they all work similarly and their name refects the type of output you want from the mapping operation: map function Output map() list map_lgl() logical vector map_int() integer vector map_dbl() double vector map_chr() character vector map_df() data frame So let’s get the column maximum’s again, but this time use the map_df function to return the output as a data frame: max_of_columns &lt;- map_df(mtcars, max) max_of_columns ## # A tibble: 1 x 11 ## mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 33.9 8 472 335 4.93 5.42 22.9 1 1 5 8 Do we always want to use map_df? Nope! It depends what we are trying to do. So before you choose your map* function, think about your downstream usage of the output of that function. What if you need to add other arguments to the functions you want to map? For example, what if there were NA values in our columns that we wanted to know the maximum of? Well then we also need to add the argument na.rm = TRUE to the max function so that we get a more useful value than NA returned (remember that is what happens with many of the built-in R statistical functions when NA’s are present…). What we need to do in that case is do what is called “creating an anonymous function” within the map_df function. We do that in the place where we previously specified our max function. Here we will put the two calls to map_df right after each other so you can see the difference: # no additional arguments to the max function map_df(mtcars, max) versus # adding the na.rm = TRUE argument to the max function map_df(mtcars, function(df) max(df, na.rm = TRUE)) You can see that’s quite a bit of extra typing… So the creators of purrr have made a shortcut for this because it is so commonly done. In the shortcut we replace function(VARIABLE) with a ~ and replace the VARIABLE in the function call with a ., see the example below: # adding the na.rm = TRUE argument to the max function using the shortcut map_df(mtcars, ~ max(., na.rm = TRUE)) 3.6.1 A bit more about the map* functions The map functions are generally quite useful for solving many iteration/repetition problems. It’s use does not have to be limited to columns of a data frame. It can be used to apply functions to elements of a vector or list, rows of a data frame (using pmap), and even to lists of data frames, or nested data frames. 3.7 Additional readings/resources Data transformation chapter from R for Data Science by Garrett Grolemund &amp; Hadley Wickham Tidy data chapter from R for Data Science by Garrett Grolemund &amp; Hadley Wickham The map functions from R for Data Science by Garrett Grolemund &amp; Hadley Wickham "]
]
