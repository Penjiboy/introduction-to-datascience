[
["classification-continued.html", "Chapter 7 Classification II: evaluation &amp; tuning 7.1 Overview 7.2 Chapter learning objectives 7.3 Evaluating accuracy 7.4 Tuning the classifier 7.5 Splitting data 7.6 Summary", " Chapter 7 Classification II: evaluation &amp; tuning 7.1 Overview This chapter continues the introduction to predictive modelling through classification. While the previous chapter covered training and data preprocessing, this chapter focuses on how to split data, how to evaluate prediction accuracy, and how to choose model parameters to maximize performance. 7.2 Chapter learning objectives By the end of the chapter, students will be able to: Describe what training, validation, and test data sets are and how they are used in classification Split data into training, validation, and test data sets Evaluate classification accuracy in R using a validation data set and appropriate metrics Execute cross-validation in R to choose the number of neighbours in a K-nearest neighbour classifier Describe advantages and disadvantages of the K-nearest neighbour classification algorithm 7.3 Evaluating accuracy Sometimes our classifier might make the wrong prediction. A classifier does not need to be right 100% of the time to be useful, though we don’t want the classifier to make too many wrong predictions. How do we measure how “good” our classifier is? Let’s revisit the breast cancer images example and think about how our classifier will be used in practice. A biopsy will be performed on a new patient’s tumour, the resulting image will be analyzed, and the classifier will be asked to decide whether the tumour is benign or malignant. The key word here is new: our classifier is “good” if it provides accurate predictions on data not seen during training. But then how can we evaluate our classifier without having to visit the hospital to collect more tumour images? The trick is to split up the data set into a training set and test set, and only show the classifier the training set when building the classifier. Then to evaluate the accuracy of the classifier, we can use it to predict the labels (which we know) in the test set. If our predictions match the true labels for the observations in the test set very well, then we have some confidence that our classifier might also do a good job of predicting the class labels for new observations that we do not have the class labels for. Note: if there were a golden rule of machine learning, it might be this: you cannot use the test data to build the model! If you do, the model gets to “see” the test data in advance, making it look more accurate than it really is. Imagine how bad it would be to overestimate your classifier’s accuracy when predicting whether a patient’s tumour is malignant or benign! How exactly can we assess how well our predictions match the true labels for the observations in the test set? One way we can do this is to calculate the prediction accuracy. This is the fraction of examples for which the classifier made the correct prediction. To calculate this we divide the number of correct predictions by the number of predictions made. Other measures for how well our classifier performed include precision and recall; these will not be discussed here, but you will encounter them in other more advanced courses on this topic. This process is illustrated below: In R, we can use the tidymodels library collection not only to perform K-nearest neighbour classification, but also to assess how well our classification worked. Let’s start by loading the necessary libraries, reading in the breast cancer data from the previous chapter, and making a quick scatter plot visualization of tumour cell concavity versus smoothness coloured by diagnosis. # load libraries library(tidyverse) library(tidymodels) #load data cancer &lt;- read_csv(&quot;data/unscaled_wdbc.csv&quot;) %&gt;% mutate(Class = as_factor(Class)) %&gt;% # convert the character Class variable to the factor datatype select(Class, Concavity, Smoothness) # colour palette cbPalette &lt;- c(&quot;#E69F00&quot;, &quot;#56B4E9&quot;, &quot;#009E73&quot;, &quot;#F0E442&quot;, &quot;#0072B2&quot;, &quot;#D55E00&quot;, &quot;#CC79A7&quot;, &quot;#999999&quot;) # create scatter plot of tumour cell concavity versus smoothness, # labelling the points be diagnosis class perim_concav &lt;- cancer %&gt;% ggplot(aes(x = Smoothness, y = Concavity, color = Class)) + geom_point(alpha = 0.5) + labs(color = &quot;Diagnosis&quot;) + scale_color_manual(labels = c(&quot;Malignant&quot;, &quot;Benign&quot;), values = cbPalette) perim_concav 1. Create the train / test split Once we have decided on a predictive question to answer and done some preliminary exploration, the very next thing to do is to split the data into the training and test sets. Typically, the training set is between 50 - 100% of the data, while the test set is the remaining 0 - 50%; the intuition is that you want to trade off between training an accurate model (by using a larger training data set) and getting an accurate evaluation of its performance (by using a larger test data set). Here, we will use 75% of the data for training, and 25% for testing. To do this we will use the initial_split function, specifying that prop = 0.75 and the target variable is Class: set.seed(1) cancer_split &lt;- initial_split(cancer, prop = 0.75, strata = Class) cancer_train &lt;- training(cancer_split) cancer_test &lt;- testing(cancer_split) Note: You will see in the code above that we use the set.seed function again, as discussed in the previous chapter. In this case it is because initial_split uses random sampling to choose which rows will be in the training set. Since we want our code to be reproducible and generate the same train/test split each time it is run, we use set.seed. glimpse(cancer_train) ## Rows: 427 ## Columns: 3 ## $ Class &lt;fct&gt; M, M, M, M, M, M, M, M, M, M, M, M, M, M, M, B, B, M, M, M… ## $ Concavity &lt;dbl&gt; 0.30010, 0.08690, 0.19740, 0.24140, 0.19800, 0.15780, 0.11… ## $ Smoothness &lt;dbl&gt; 0.11840, 0.08474, 0.10960, 0.14250, 0.10030, 0.12780, 0.09… glimpse(cancer_test) ## Rows: 142 ## Columns: 3 ## $ Class &lt;fct&gt; M, M, M, M, B, M, M, M, M, M, M, B, B, M, M, M, B, M, M, B… ## $ Concavity &lt;dbl&gt; 0.18590, 0.16390, 0.07395, 0.14790, 0.06664, 0.20770, 0.23… ## $ Smoothness &lt;dbl&gt; 0.12730, 0.11390, 0.09867, 0.09831, 0.09779, 0.10730, 0.10… We can see from glimpse in the code above that the training set contains 427 observations, while the test set contains 142 observations. This corresponds to a train / test split of 75% / 25%, as desired. 2. Pre-process the data As we mentioned last chapter, k-nn is sensitive to the scale of the predictors, and so we should perform some preprocessing to standardize them. An additional consideration we need to take when doing this is that we should create the scaling transformer using only the training data. This ensures that our test data does not influence any aspect of our model training. Once we have created the scaling transformer, we can then apply it separately to both the training and test data sets. Fortunately, the recipe framework from tidymodels makes it simple to handle this properly. Below we construct and prepare the recipe using only the training data (due to data = cancer_train in the first line), and then apply it to both the training and testing data. cancer_recipe &lt;- recipe(Class ~ ., data = cancer_train) %&gt;% step_scale(all_numeric()) %&gt;% step_center(all_numeric()) %&gt;% prep() cancer_train_baked &lt;- bake(cancer_recipe, cancer_train) cancer_test_baked &lt;- bake(cancer_recipe, cancer_test) 3. Train the classifier Now that we have split our original data set into training and test sets, we can create our K-nearest neighbour classifier with only the training set using the technique we learned in the previous chapter. For now, we will just choose the number \\(K\\) of neighbours to be 3, and use concavity and smoothness as the predictors. set.seed(1) knn_spec &lt;- nearest_neighbor(weight_func = &quot;rectangular&quot;, neighbors = 3) %&gt;% set_engine(&quot;kknn&quot;) %&gt;% set_mode(&quot;classification&quot;) knn_fit &lt;- knn_spec %&gt;% fit(Class ~ ., data = cancer_train_baked) knn_fit ## parsnip model object ## ## Fit time: 10ms ## ## Call: ## kknn::train.kknn(formula = formula, data = data, ks = ~3, kernel = ~&quot;rectangular&quot;) ## ## Type of response variable: nominal ## Minimal misclassification: 0.1264637 ## Best kernel: rectangular ## Best k: 3 Note: Here again you see the set.seed function. In the K-nearest neighbour algorithm, there is a tie for the majority neighbour class, the winner is randomly selected. Although there is no chance of a tie when \\(K\\) is odd (here \\(K=3\\)), it is possible that the code may be changed in the future to have an even value of \\(K\\). Thus, to prevent potential issues with reproducibility, we have set the seed. Note that in your own code, you only have to set the seed once at the beginning of your analysis. 4. Predict the labels in the test set Now that we have a K-nearest neighbour classifier object, we can use it to predict the class labels for our test set. We use the bind_cols to add the column of predictions to the original test data, creating the cancer_test_predictions data frame. The Class variable contains the true diagnoses, while the .pred_class contains the predicted diagnoses from the model. cancer_test_predictions &lt;- predict(knn_fit, cancer_test_baked) %&gt;% bind_cols(cancer_test_baked) head(cancer_test_predictions) ## # A tibble: 6 x 4 ## .pred_class Concavity Smoothness Class ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 M 1.19 2.16 M ## 2 M 0.923 1.23 M ## 3 B -0.190 0.166 M ## 4 M 0.725 0.141 M ## 5 B -0.281 0.104 B ## 6 M 1.46 0.767 M 5. Compute the accuracy Finally we can assess our classifier’s accuracy. To do this we use the metrics function from tidymodels to get the statistics about the quality of our model, specifying the truth and estimate arguments: cancer_test_predictions %&gt;% metrics(truth = Class, estimate = .pred_class) ## # A tibble: 2 x 3 ## .metric .estimator .estimate ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 accuracy binary 0.880 ## 2 kap binary 0.741 This shows that the accuracy of the classifier on the test data was 88%. We can also look at the confusion matrix for the classifier, which shows the table of predicted labels and correct labels, using the conf_mat function: cancer_test_predictions %&gt;% conf_mat(truth = Class, estimate = .pred_class) ## Truth ## Prediction M B ## M 43 7 ## B 10 82 This says that the classifier labelled 43+82 = 125 observations correctly, 10 observations as benign when they were truly malignant, and 7 observations as malignant when they were truly benign. 7.4 Tuning the classifier The vast majority of predictive models in statistics and machine learning have parameters that you have to pick. For example, in the K-nearest neighbour classification algorithm we have been using in the past two chapters, we have had to pick the number of neighbours \\(K\\) for the class vote. Is it possible to make this selection, i.e., tune the model, in a principled way? Ideally what we want is to somehow maximize the performance of our classifier on data it hasn’t seen yet. So we will play the same trick we did before when evaluating our classifier: we’ll split our overall training data set further into two subsets, called the training set and validation set. We will use the newly-named training set for building the classifier, and the validation set for evaluating it! Then we will try different values of the parameter \\(K\\) and pick the one that yields the highest accuracy. Remember: don’t touch the test set during the tuning process. Tuning is a part of model training! 7.4.1 Cross-validation There is an important detail to mention about the process of tuning: we can, if we want to, split our overall training data up in multiple different ways, train and evaluate a classifier for each split, and then choose the parameter based on all of the different results. If we just split our overall training data once, our best parameter choice will depend strongly on whatever data was lucky enough to end up in the validation set. Perhaps using multiple different train / validation splits, we’ll get a better estimate of accuracy, which will lead to a better choice of the number of neighbours \\(K\\) for the overall set of training data. Note: you might be wondering why we can’t we use the multiple splits to test our final classifier after tuning is done. This is simply because at the end of the day, we will produce a single classifier using our overall training data. If we do multiple train / test splits, we will end up with multiple classifiers, each with their own accuracy evaluated on different test data. Let’s investigate this idea in R! In particular, we will use different seed values in the set.seed function to generate five different train / validation splits of our overall training data, train five different K-nearest neighbour models, and evaluate their accuracy. accuracies &lt;- c() for (i in 1:5){ set.seed(i) # makes the random selection of rows reproducible # create the 25/75 split of the training data into training and validation cancer_split &lt;- initial_split(cancer_train, prop = 0.75, strata = Class) cancer_subtrain &lt;- training(cancer_split) cancer_validation &lt;- testing(cancer_split) # train the KNN model with K = 3 knn_spec &lt;- nearest_neighbor(weight_func = &quot;rectangular&quot;, neighbors = 3) %&gt;% set_engine(&quot;kknn&quot;) %&gt;% set_mode(&quot;classification&quot;) knn_fit &lt;- knn_spec %&gt;% fit(Class ~ ., data = cancer_subtrain) # get predictions on the validation data validation_predicted &lt;- predict(knn_fit, cancer_validation) %&gt;% bind_cols(cancer_validation) #compute the accuracy acc &lt;- validation_predicted %&gt;% metrics(truth = Class, estimate = .pred_class) %&gt;% filter(.metric == &quot;accuracy&quot;) %&gt;% select(.estimate) %&gt;% pull() accuracies &lt;- append(accuracies, acc) } accuracies ## [1] 0.9150943 0.8679245 0.8490566 0.8962264 0.9150943 With five different shuffles of the data, we get five different values for accuracy. None of these is necessarily “more correct” than any other; they’re just five estimates of the true, underlying accuracy of our classifier built using our overall training data. We can combine the estimates by taking their average (here 0.8886792) to try to get a single assessment of our classifier’s accuracy; this has the effect of reducing the influence of any one (un)lucky validation set on the estimate. In practice, we don’t use random splits, but rather use a more structured splitting procedure so that each observation in the data set is used in a validation set only a single time. The name for this strategy is called cross-validation. In cross-validation, we split our overall training data into \\(C\\) evenly-sized chunks, and then iteratively use \\(1\\) chunk as the validation set and combine the remaining \\(C-1\\) chunks as the training set: In the picture above, \\(C=5\\) different chunks of the data set are used, resulting in 5 different choices for the validation set; we call this 5-fold cross-validation. To do 5-fold cross-validation in R with tidymodels, we use another function: vfold_cv. This function splits our training data into v folds automatically: cancer_vfold &lt;- vfold_cv(cancer_train, v = 5, repeats = 1, strata = Class) cancer_vfold ## # 5-fold cross-validation using stratification ## # A tibble: 5 x 2 ## splits id ## &lt;list&gt; &lt;chr&gt; ## 1 &lt;split [341/86]&gt; Fold1 ## 2 &lt;split [341/86]&gt; Fold2 ## 3 &lt;split [341/86]&gt; Fold3 ## 4 &lt;split [342/85]&gt; Fold4 ## 5 &lt;split [343/84]&gt; Fold5 Then, when we create our classifier, we add an additional argument to train called trControl, which we set to the train_control object we just created. One benefit of using caret for this is that we do not need to manually do any of the work of cross-validation ourselves; the train function will handle creating the chunks, doing multiple rounds of training and evaluation, and averaging the results for us. set.seed(1234) k = data.frame(k = 3) knn_model_cv_5fold &lt;- train(x = X_train_total, y = Y_train_total, method = &quot;knn&quot;, tuneGrid = k, trControl = train_control) knn_model_cv_5fold ## k-Nearest Neighbors ## ## 27 samples ## 2 predictor ## 2 classes: &#39;M&#39;, &#39;B&#39; ## ## No pre-processing ## Resampling: Cross-Validated (10 fold) ## Summary of sample sizes: 23, 25, 23, 24, 24, 25, ... ## Resampling results: ## ## Accuracy Kappa ## 0.9083333 0.8 ## ## Tuning parameter &#39;k&#39; was held constant at a value of 3 Note: we set the seed when we call train not only because of the potential for ties, but also because we are doing cross-validation. Cross-validation uses a random process to select how to partition the training data. We can choose any number of folds, and typically the more we use the better our accuracy estimate will be. However, we are limited by computational power: the more folds we choose, the more computation it takes, and hence the more time it takes to run the analysis. So when you do cross-validation, you need to consider the size of the data, and the speed of the algorithm (e.g., K-nearest neighbour) and the speed of your computer. In practice, this is a trial and error process, but typically \\(C\\) is chosen to be either 5 or 10. Here we show what happens when we split the data into 10 chunks and do 10-fold cross-validation: train_control &lt;- trainControl(method=&quot;cv&quot;, number = 10) set.seed(1234) knn_model_cv_10fold &lt;- train(x = X_train_total, y = Y_train_total, method = &quot;knn&quot;, tuneGrid = k, trControl = train_control) knn_model_cv_10fold ## k-Nearest Neighbors ## ## 27 samples ## 2 predictor ## 2 classes: &#39;M&#39;, &#39;B&#39; ## ## No pre-processing ## Resampling: Cross-Validated (10 fold) ## Summary of sample sizes: 23, 25, 23, 24, 24, 25, ... ## Resampling results: ## ## Accuracy Kappa ## 0.9083333 0.8 ## ## Tuning parameter &#39;k&#39; was held constant at a value of 3 7.4.2 Parameter value selection Using 5- and 10-fold cross-validation, we have estimated that the prediction accuracy of our classifier is somewhere around 88%. Whether 88% is good or not depends entirely on the downstream application of the data analysis. In the present situation, we are trying to predict a tumour diagnosis, with expensive, damaging chemo/radiation therapy or patient death as potential consequences of misprediction. Hence, we’d like to do better than 88% for this application. In order to improve our classifier, we have one choice of parameter: the number of neighbours, \\(K\\). Since cross-validation helps us evaluate the accuracy of our classifier, we can use cross-validation to calculate an accuracy for each value of \\(K\\) in a reasonable range, and then pick the value of \\(K\\) that gives us the best accuracy. In R, we can accomplish this tuning by passing a vector of values for \\(K\\) to the tuneGrid argument of train. train_control &lt;- trainControl(method=&quot;cv&quot;, number = 10) k = data.frame(k = c(1, 3, 5, 7, 9, 11, 13, 15, 17)) set.seed(1234) knn_model_cv_10fold &lt;- train(x = X_train_total, y = Y_train_total, method = &quot;knn&quot;, tuneGrid = k, trControl = train_control) knn_model_cv_10fold ## k-Nearest Neighbors ## ## 27 samples ## 2 predictor ## 2 classes: &#39;M&#39;, &#39;B&#39; ## ## No pre-processing ## Resampling: Cross-Validated (10 fold) ## Summary of sample sizes: 23, 25, 23, 24, 24, 25, ... ## Resampling results across tuning parameters: ## ## k Accuracy Kappa ## 1 0.9166667 0.84 ## 3 0.9083333 0.80 ## 5 0.9333333 0.85 ## 7 0.9333333 0.85 ## 9 0.9666667 0.90 ## 11 0.9416667 0.85 ## 13 0.9416667 0.85 ## 15 0.9166667 0.80 ## 17 0.8333333 0.60 ## ## Accuracy was used to select the optimal model using the largest value. ## The final value used for the model was k = 9. Although caret provides a selection of \\(K=13\\) for us by maximizing the accuracy estimate, it is helpful regardless to visualize the accuracy as we increase \\(K\\). We can access the results from the cross-validation via theresults attribute of the train object (our classifier). accuracies &lt;- knn_model_cv_10fold$results accuracies ## k Accuracy Kappa AccuracySD KappaSD ## 1 1 0.9166667 0.84 0.1800206 0.3502380 ## 2 3 0.9083333 0.80 0.2167735 0.4830459 ## 3 5 0.9333333 0.85 0.2108185 0.4743416 ## 4 7 0.9333333 0.85 0.2108185 0.4743416 ## 5 9 0.9666667 0.90 0.1054093 0.3162278 ## 6 11 0.9416667 0.85 0.1245362 0.3374743 ## 7 13 0.9416667 0.85 0.1245362 0.3374743 ## 8 15 0.9166667 0.80 0.1360828 0.3496029 ## 9 17 0.8333333 0.60 0.1883981 0.4594683 Now we can plot accuracy versus \\(K\\): accuracy_vs_k &lt;- ggplot(accuracies, aes(x = k, y = Accuracy)) + geom_point() + geom_line() accuracy_vs_k Based off of the visualization above, we might agree with caret’s choice of \\(K=13\\). But as you can see, there is no exact or perfect answer here; any choice between \\(K=9\\) and \\(K = 17\\) would be reasonably justified. Remember: the values you see on this plot are estimates of the true accuracy of our classifier. Although the \\(K=13\\) value is higher than the others on this plot, that doesn’t mean the classifier is actually more accurate with this parameter value! Generally, when selecting \\(K\\) (and other parameters for other predictive models), we are looking for a value where: we get roughly optimal accuracy, so that our model will likely be accurate changing the value to a nearby one (e.g. from \\(K=13\\) to 12 or 14) doesn’t decrease accuracy too much, so that our choice is reliable in the presence of uncertainty the cost of training the model is not prohibitive (e.g., in our situation, if \\(K\\) is too large, predicting becomes expensive!) 7.4.3 Under/overfitting To build a bit more intuition, what happens if we keep increasing the number of neighbours \\(K\\)? In fact, the accuracy actually starts to decrease! Take a look as the plot below as we vary \\(K\\) from 1 to almost the number of observations in the data set: train_control &lt;- trainControl(method=&quot;cv&quot;, number = 10) k_lots = data.frame(k = seq(from = 1, to = 385, by = 10)) set.seed(1234) knn_model_cv_10fold_lots &lt;- train(x = X_train_total, y = Y_train_total, method = &quot;knn&quot;, tuneGrid = k_lots, trControl = train_control) accuracies_lots &lt;- knn_model_cv_10fold_lots$results accuracy_vs_k_lots &lt;- ggplot(accuracies_lots, aes(x = k, y = Accuracy)) + geom_point() + geom_line() accuracy_vs_k_lots Underfitting: What is actually happening to our classifier that causes this? As we increase the number of neighbours, more and more of the training observations (and those that are farther and farther away from the point) get a “say” in what the class of a new observation is. This causes a sort of “averaging effect” to take place, making the boundary between where our classifier would predict a tumour to be malignant versus benign to smooth out and become simpler. If you take this to the extreme, setting \\(K\\) to the total training data set size, then the classifier will always predict the same label regardless of what the new observation looks like. In general, if the model isn’t influenced enough by the training data, it is said to underfit the data. Overfitting: In contrast, when we decrease the number of neighbours, each individual data point has a stronger and stronger vote regarding nearby points. Since the data themselves are noisy, this causes a more “jagged” boundary corresponding to a less simple model. If you take this case to the extreme, setting \\(K = 1\\), then the classifier is essentially just matching each new observation to its closest neighbour in the training data set. This is just as problematic as the large \\(K\\) case, because the classifier becomes unreliable on new data: if we had a different training set, the predictions would be completely different. In general, if the model is influenced too much by the training data, it is said to overfit the data. You can see this effect in the plots below as we vary the number of neighbours \\(K\\) in (1, 7, 20, 200): 7.5 Splitting data Shuffling: When we split the data into train, test, and validation sets, we make the assumption that there is no order to our originally collected data set. However, if we think that there might be some order to the original data set, then we can randomly shuffle the data before splitting it. The caret package’s createDataPartition function does this for us. Stratification: If the data are imbalanced, we also need to be extra careful about splitting the data to ensure that enough of each class ends up in each of the train, validation, and test partitions. Luckily, the createDataPartition does this for us as well. 7.6 Summary Classification algorithms use one or more quantitative variables to predict the value of a third, categorical variable. The K-nearest neighbour algorithm in particular does this by first finding the K points in the training data nearest to the new observation, and then returning the majority class vote from those training observations. We can evaluate a classifier by splitting the data randomly into a training and test data set, using the training set to build the classifier, and using the test set to estimate its accuracy. To tune the classifier (e.g., select the K in K-nearest neighbours), we maximize accuracy estimates from cross-validation. A typical 10-fold cross-validation data set split. Source: https://towardsdatascience.com/train-test-split-and-cross-validation-in-python-80b61beca4b6 The overall workflow for performing K-nearest neighbour classification in caret is as follows: Use the createDataPartition function to split the data into a training and test set. Put the test set aside for now. Use the trainControl function to specify whether to use cross-validation and how many folds Use the train function to train and evaluate the classifier for different values of \\(K\\) Retrain the classifier on all the training data, using the best parameter from the previous step Evaluate the estimated accuracy of the classifier on the test set Strengths: Simple and easy to understand No assumptions about what the data must look like Works easily for binary (two-class) and multi-class (&gt; 2 classes) classification problems Weaknesses: As data gets bigger and bigger, K-nearest neighbour gets slower and slower, quite quickly Does not perform well with a large number of predictors Does not perform well when classes are imbalanced (when many more observations are in one of the classes compared to the others) "]
]
