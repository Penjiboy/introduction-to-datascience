[
["index.html", "Introduction to Data Science Chapter 1 Introduction to Data Science 1.1 Chapter learning objectives 1.2 Jupyter notebooks 1.3 Loading a spreadsheet-like dataset 1.4 Assigning value to a data frame 1.5 Creating subsets of data frames with select &amp; filter 1.6 Exploring data with visualizations", " Introduction to Data Science Tiffany-Anne Timbers Melissa Lee Trevor Campbell 2019-10-22 Chapter 1 Introduction to Data Science This is an open source textbook aimed at introducing undergraduate students to data science. It was originally written for the University of British Columbia’s DSCI 100 - Introduction to Data Science course. In this book, we define data science as the study and development of reproducible, auditable processes to obtain value (i.e., insight) from data. The book is structured so that learners spend the first four chapters learning how to use the R programming language and Jupyter notebooks to load, wrangle/clean, and visualize data, while answering descriptive and exploratory data analysis questions. The remaining chapters illustrate how to solve four common problems in data science, which are useful for answering predictive and inferential data analysis questions: Predicting a class/category for a new observation/measurement (e.g., cancerous or benign tumour) Predicting a value for a new observation/measurement (e.g., 10 km race time for 20 year old females with a BMI of 25). Finding previously unknown/unlabelled subgroups in your data (e.g., products commonly bought together on Amazon) Estimating an average or a proportion from a representative sample (group of people or units) and using that estimate to generalize to the broader population (e.g., the proportion of undergraduate students that own an iphone) For each of these problems, we map them to the type of data analysis question being asked and discuss what kinds of data are needed to answer such questions. More advanced (e.g., causal or mechanistic) data analysis questions are beyond the scope of this text. Types of data analysis questions Question type Description Example Descriptive A question which asks about summarized characteristics of a data set without interpretation (i.e., report a fact). How many people live in each US state? Exploratory A question asks if there are patterns, trends, or relationships within a single data set. Often used to propose hypotheses for future study. Does politcal party voting change with indicators of wealth in a set of data collected from groups of individuals from several regions in the United States? Inferential A question that looks for patterns, trends, or relationships in a single data set and also asks for quantification of how applicable these findings are to the wider population. Does politcal party voting change with indicators of wealth in the United States? Predictive A question that asks about predicting measurements or labels for individuals (people or things). The focus is on what things predict some outcome, but not what causes the outcome. What political party will someone vote for in the next US election? Causal A question that asks about whether changing one factor will lead to a change in another factor, on average, in the wider population. Does wealth lead to voting for a certain political party candidate in the US Presidential election? Mechanistic A question that asks about the underlying mechanism of the observed patterns, trends, or relationship (i.e., how does it happen?) How does wealth lead to voting for a certain political party candidate in the US Presidential election? Source: What is the question? by Jeffery T. Leek, Roger D. Peng &amp; The Art of Data Science by Roger Peng &amp; Elizabeth Matsui 1.1 Chapter learning objectives By the end of the chapter, students will be able to: use a Jupyter notebook to execute provided R code edit code and markdown cells in a Jupyter notebook create new code and markdown cells in a Jupyter notebook load the tidyverse library into R create new variables and objects in R using the assignment symbol use the help and documentation tools in R match the names of the following functions from the tidyverse library to their documentation descriptions: read_csv select mutate filter ggplot aes 1.2 Jupyter notebooks Jupyter notebooks are documents that contain a mix of computer code (and its output) and formattable text. Given that they are able to combine these two in a single document—code is not separate from the output or written report—notebooks are one of the leading tools to create reproducible data analyses. A reproducible data analysis is one where you can reliably and easily recreate the same results when analyzing the same data. Although this sounds like something that should always be true of any data analysis, in reality this is not often the case; one needs to make a conscious effort to perform data analysis in a reproducible manner. The name Jupyter came from combining the names of the three programming language that it was initially targeted for (Julia, Python, and R), and now many other languages can be used with Jupyter notebooks. A notebook looks like this: We have included a short demo video here to help you get started and to introduce you to R and Jupyter. However, the best way to learn how to write and run code and formattable text in a Jupyter notebook is to do it yourself! Here is a worksheet that provides a step-by-step guide through the basics. 1.3 Loading a spreadsheet-like dataset Often, the first thing we need to do in data analysis is to load a dataset into R. When we bring spreadsheet-like (think Microsoft Excel tables) data, generally shaped like a rectangle, into R it is represented as what we call a data frame object. It is very similar to a spreadsheet where the rows are the collected observations and the columns are the variables. The first kind of data we will learn how to load into R (as a data frame) is the spreadsheet-like comma-separated values format (.csv for short). These files have names ending in .csv, and can be opened open and saved from common spreadsheet programs like Microsoft Excel and Google Sheets. For example, a .csv file named state_property_vote.csv is included with the code for this book. This file— originally from Data USA—has US state-level property, income, population and voting data from 2015 and 2016. If we were to open this data in a plain text editor, we would see each row on its own line, and each entry in the table separated by a comma: state,med_income,med_prop_val,population,mean_commute_minutes,party AK,64222,197300,733375,10.46830207,Republican AL,36924,94800,4830620,25.30990746,Republican AR,35833,83300,2958208,22.40108933,Republican AZ,44748,128700,6641928,20.58786,Republican CA,53075,252100,38421464,23.38085172,Democrat CO,48098,198900,5278906,19.50792188,Democrat CT,69228,246450,3593222,24.349675,Democrat DC,70848,475800,647484,28.2534,Democrat DE,54976,228500,926454,24.45553333,Democrat To load this data into R, and then to do anything else with it afterwards, we will need to use something called a function. A function is a special word in R that takes in instructions (we call these arguments) and does something. The function we will use to read a .csv file into R is called read_csv. In its most basic use-case, read_csv expects that the data file: has column names (or headers), uses a comma (,) to separate the columns, and does not have row names. Below you’ll see the code used to load the data into R using the read_csv function. But there is one extra step we need to do first. Since read_csv is not included in the base installation of R, to be able to use it we have to load it from somewhere else: a collection of useful functions known as a library. The read_csv function in particular is in the tidyverse library (more on this later), which we load using the library function. Next, we call the read_csv function and pass it a single argument: the name of the file, &quot;state_property_vote.csv&quot;. We have to put quotes around filenames and other letters and words that we use in our code to distinguish it from the special words that make up R programming language. This is the only argument we need to provide for this file, because our file satifies everthing else the read_csv function expects in the default use-case (which we just discussed). Later in the course, we’ll learn more about how to deal with more complicated files where the default arguments are not appropriate. For example, files that use spaces or tabs to separate the columns, or with no column names. library(tidyverse) read_csv(&quot;state_property_vote.csv&quot;) ## # A tibble: 52 x 6 ## state med_income med_prop_val population mean_commute_minutes party ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 AK 64222 197300 733375 10.5 Republican ## 2 AL 36924 94800 4830620 25.3 Republican ## 3 AR 35833 83300 2958208 22.4 Republican ## 4 AZ 44748 128700 6641928 20.6 Republican ## 5 CA 53075 252100 38421464 23.4 Democrat ## 6 CO 48098 198900 5278906 19.5 Democrat ## 7 CT 69228 246450 3593222 24.3 Democrat ## 8 DC 70848 475800 647484 28.3 Democrat ## 9 DE 54976 228500 926454 24.5 Democrat ## 10 FL 43355 125600 19645772 24.8 Republican ## # … with 42 more rows Above you can also see something neat that Jupyter does to help us understand our code: it colours text depending on its meaning in R. For example, you’ll note that functions get bold green text, while letters and words surrounded by quotations like filenames get blue text. In case you want to know more (optional): We use the read_csv function from the tidyverse instead of the base R function read.csv because it’s faster and it creates a nicer variant of the base R data frame called a tibble. This has several benefits that we’ll discuss in further detail later in the course. 1.4 Assigning value to a data frame When we loaded the US state-level property, income, population, and voting data in R above using read_csv, we did not give this data frame a name, so it was just printed to the screen and we cannot do anything else with it. That isn’t very useful; what we would like to do is give a name to the data frame that read_csv outputs so that we can use it later for analysis and visualization. To assign name to something in R, there are two possible ways—using either the assignment symbol (&lt;-) or the equals symbol (=). From a style perspective, the assignment symbol is preferred and is what we will use in this course. When we name something in R using the assignment symbol, &lt;-, we do not need to surround it with quotes like the filename. This is because we are formally telling R about this word and giving it a value. Only characters and words that act as values need to be surrounded by quotes. Let’s now use the assignment symbol to give the name us_data to the US state-level property, income, population, and voting data frame that we get from read_csv. us_data &lt;- read_csv(&quot;state_property_vote.csv&quot;) Wait a minute! Nothing happened this time! Or at least it looks like that. But actually something did happen: the data was read in and now has the name us_data associated with it. And we can use that name to access the data frame and do things with it. First we will type the name of the data frame to print it to the screen. us_data ## # A tibble: 52 x 6 ## state med_income med_prop_val population mean_commute_minutes party ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 AK 64222 197300 733375 10.5 Republican ## 2 AL 36924 94800 4830620 25.3 Republican ## 3 AR 35833 83300 2958208 22.4 Republican ## 4 AZ 44748 128700 6641928 20.6 Republican ## 5 CA 53075 252100 38421464 23.4 Democrat ## 6 CO 48098 198900 5278906 19.5 Democrat ## 7 CT 69228 246450 3593222 24.3 Democrat ## 8 DC 70848 475800 647484 28.3 Democrat ## 9 DE 54976 228500 926454 24.5 Democrat ## 10 FL 43355 125600 19645772 24.8 Republican ## # … with 42 more rows 1.5 Creating subsets of data frames with select &amp; filter Now, we are going to learn how to obtain subsets of data from a data frame in R using two other tidyverse functions: select and filter. The select function allows you to create a subset of the columns of a data frame, while the filter function allows you to obtain a subset of the rows with specific values. Before we start using select and filter, let’s take a look at the US state-level property, income, and population data again to familiarize ourselves with it. We will do this by printing the data we loaded earlier in the chapter to the screen. us_data ## # A tibble: 52 x 6 ## state med_income med_prop_val population mean_commute_minutes party ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 AK 64222 197300 733375 10.5 Republican ## 2 AL 36924 94800 4830620 25.3 Republican ## 3 AR 35833 83300 2958208 22.4 Republican ## 4 AZ 44748 128700 6641928 20.6 Republican ## 5 CA 53075 252100 38421464 23.4 Democrat ## 6 CO 48098 198900 5278906 19.5 Democrat ## 7 CT 69228 246450 3593222 24.3 Democrat ## 8 DC 70848 475800 647484 28.3 Democrat ## 9 DE 54976 228500 926454 24.5 Democrat ## 10 FL 43355 125600 19645772 24.8 Republican ## # … with 42 more rows In this data frame there are 52 rows (corresponding to the 50 US states, the District of Columbia and the US territory, Puerto Rico) and 6 columns: US state abbreviation Median household income Median property value US state population Mean commute time in minutes The party each state voted for in the 2016 US presidential election Now let’s use select to extract the state column from this data frame. To do this, we need to provide the select function with two arguments. The first argument is the name of the data frame object, which in this example is us_data. The second argument is the column name that we want to select, here state. After passing these two arguments, the select function returns a single column (the state column that we asked for) as a data frame. state_column &lt;- select(us_data, state) state_column ## # A tibble: 52 x 1 ## state ## &lt;chr&gt; ## 1 AK ## 2 AL ## 3 AR ## 4 AZ ## 5 CA ## 6 CO ## 7 CT ## 8 DC ## 9 DE ## 10 FL ## # … with 42 more rows 1.5.1 Using select to extract multiple columns We can also use select to obtain a subset of the data frame with multiple columns. Again, the first argument is the name of the data frame. Then we list all the columns we want as arguments separated by commas. Here we create a subset of three columns: state, median property value, and mean commute time in minutes. three_columns &lt;- select(us_data, state, med_prop_val, mean_commute_minutes) three_columns ## # A tibble: 52 x 3 ## state med_prop_val mean_commute_minutes ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AK 197300 10.5 ## 2 AL 94800 25.3 ## 3 AR 83300 22.4 ## 4 AZ 128700 20.6 ## 5 CA 252100 23.4 ## 6 CO 198900 19.5 ## 7 CT 246450 24.3 ## 8 DC 475800 28.3 ## 9 DE 228500 24.5 ## 10 FL 125600 24.8 ## # … with 42 more rows 1.5.2 Using select to extract a range of columns We can also use select to obtain a subset of the data frame constructed from a range of columns. To do this we use the colon (:) operator to denote the range. For example, to get all the columns in the data frame from state to med_prop_val we pass state:med_prop_val as the second argument to the select function. column_range &lt;- select(us_data, state:med_prop_val) column_range ## # A tibble: 52 x 3 ## state med_income med_prop_val ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AK 64222 197300 ## 2 AL 36924 94800 ## 3 AR 35833 83300 ## 4 AZ 44748 128700 ## 5 CA 53075 252100 ## 6 CO 48098 198900 ## 7 CT 69228 246450 ## 8 DC 70848 475800 ## 9 DE 54976 228500 ## 10 FL 43355 125600 ## # … with 42 more rows 1.5.3 Using filter to extract a single row We can use the filter function to obtain the subset of rows with desired values from a data frame. Again, our first argument is the name of the data frame object, us_data. The second argument is a logical statement to use when filtering the rows. Here, for example, we’ll say that we are interested in rows where state equals NY (for New York). To make this comparison, we use the equivalency operator == to compare the values of the state column with the value &quot;NY&quot;. Similar to when we loaded the data file and put quotes around the filename, here we need to put quotes around &quot;NY&quot; to tell R that this is a character value and not one of the special words that make up R programming language, nor one of the names we have given to data frames in the code we have already written. With these arguments, filter returns a data frame that has all the columns of the input data frame but only the rows we asked for in our logical filter statement. new_york &lt;- filter(us_data, state == &quot;NY&quot;) new_york ## # A tibble: 1 x 6 ## state med_income med_prop_val population mean_commute_minutes party ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 NY 50839 134150 19673174 24.4 Democrat 1.5.4 Using filter to extract rows with values above a threshold If we are interested in finding information about the states who have a longer mean commute time than New York—whose mean commute time is 21.5 minutes—then we can create a filter to obtain rows where the value of mean_commute_minutes is greater than 21.5. In this case, we see that filter returns a data frame with 33 rows; this indicates that there are 33 states with longer commute times on average than New York. long_commutes &lt;- filter(us_data, mean_commute_minutes &gt; 21.5) long_commutes ## # A tibble: 33 x 6 ## state med_income med_prop_val population mean_commute_minutes party ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 AL 36924 94800 4830620 25.3 Republican ## 2 AR 35833 83300 2958208 22.4 Republican ## 3 CA 53075 252100 38421464 23.4 Democrat ## 4 CT 69228 246450 3593222 24.3 Democrat ## 5 DC 70848 475800 647484 28.3 Democrat ## 6 DE 54976 228500 926454 24.5 Democrat ## 7 FL 43355 125600 19645772 24.8 Republican ## 8 GA 37865 101700 10006693 24.5 Republican ## 9 IL 47898 97350 12873761 22.6 Democrat ## 10 IN 47194 111800 6568645 23.5 Republican ## # … with 23 more rows 1.6 Exploring data with visualizations Creating effective data visualizations is an essential piece to any data analysis. For the remainder of Chapter 1, we will learn how to use functions from the tidyverse to make visualizations that let us explore relationships in data. In particular, we’ll develop a visualization of the US property, income, population, and voting data we’ve been working with that will help us understand two potential relationships in the data: first, the relationship between median household income and median propery value across the US, and second, whether there is a pattern in which party each state voted for in the 2016 US election. This is an example of an exploratory data analysis question: we are looking for relationships and patterns within the data set we have, but are not trying to generalize what we find beyond this data set. 1.6.1 Using ggplot to create a scatter plot Taking another look at our dataset below, we can immediately see that the three columns (or variables) we are interested in visualizing—median household income, median property value, and election result—are all in separate columns. In addition, there is a single row (or observation) for each state. The data are therefore in what we call a tidy data format. This is particularly important and will be a major focus in the remainder of this course: many of the functions from tidyverse require tidy data, including the ggplot function that we will use shortly for our visualization. Note below that we use the print function to display the us_data rather than just typing us_data; for data frames, these do the same thing. print(us_data) ## # A tibble: 52 x 6 ## state med_income med_prop_val population mean_commute_minutes party ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 AK 64222 197300 733375 10.5 Republican ## 2 AL 36924 94800 4830620 25.3 Republican ## 3 AR 35833 83300 2958208 22.4 Republican ## 4 AZ 44748 128700 6641928 20.6 Republican ## 5 CA 53075 252100 38421464 23.4 Democrat ## 6 CO 48098 198900 5278906 19.5 Democrat ## 7 CT 69228 246450 3593222 24.3 Democrat ## 8 DC 70848 475800 647484 28.3 Democrat ## 9 DE 54976 228500 926454 24.5 Democrat ## 10 FL 43355 125600 19645772 24.8 Republican ## # … with 42 more rows 1.6.2 Using ggplot to create a scatter plot We will begin with a scatter plot of the income and property value columns from our data frame. To create a scatter plot of these two variables using the ggplot function, we do the following: call the ggplot function provide the name of the data frame as the first argument call the aesthetic function, aes, to specify which column will correspond to the x-axis and which will correspond to the y-axis add a + symbol at the end of the ggplot call to add a layer to the plot call the geom_point function to tell R that we want to represent the data points as dots/points to create a scatter plot. ggplot(us_data, aes(x = med_income, y = med_prop_val)) + geom_point() In case you have used R before and are curious: There are a small number of situations in which you can have a single R expression span multiple lines. Here, the + symbol at the end of the first line tells R that the expression isn’t done yet and to continue reading on the next line. While not strictly necessary, this sort of pattern will appear a lot when using ggplot as it keeps things more readable. 1.6.3 Formatting ggplot objects One common and easy way to format your ggplot visualization is to add additional layers to the plot object using the + symbol. For example, we can use the xlab and ylab functions to add layers where we specify human readable labels for the x and y axes. Again, since we are specifying words (e.g. &quot;Income (USD)&quot;) as arguments to xlab and ylab, we surround them with double quotes. There are many more layers we can add to format the plot further, and we will explore these in later chapters. ggplot(us_data, aes(x = med_income, y = med_prop_val)) + geom_point() + xlab(&quot;Income (USD)&quot;) + ylab(&quot;Median property value (USD)&quot;) From this visualization we see that for the 52 US regions in this data set, as median household income increases so does median property value. When we see two variables do this, we call this a positive relationship. Because the increasing pattern is fairly clear (not fuzzy) we can say that the relationship is strong. Because of the data point in the lower left-hand corner, drawing a straight line through these points wouldn’t fit very well. When a straight-line doesn’t fit the data well we say that it’s non-linear. However, we should have caution when using one point to claim non-linearity. As we will see later, this might be due to a single point not really belonging in the data set (this is often called an outlier). Learning how to describe data visualizations is a very useful skill. We will provide descriptions for you in this course (as we did above) until we get to Chapter 4, which focuses on data visualization. Then, we will explicitly teach you how to do this yourself, and how to not over-state or over-interpret the results from a visualization. 1.6.4 Coloring points by group Now we’ll move onto the second part of our exploratory data analysis question: when considering the relationship between median household income and median property value, is there a pattern in which party each state voted for in the 2016 US election? One common way to explore this is to colour the data points on the scatter plot we have already created by group/category. For example, given that we have the party each state voted for in the 2016 US Presidential election in the column named party, we can colour the points in our previous scatter plot to represent who each stated voted for. To do this we modify our scatter plot code above. Specifically, we will add an argument to the aes function, specifying that the points should be coloured by the party column: ggplot(us_data, aes(x = med_income, y = med_prop_val, color = party)) + geom_point() + xlab(&quot;Income (USD)&quot;) + ylab(&quot;Median property value (USD)&quot;) This data visualization shows that the one data point we singled out earlier on the far left of the plot has the label of “not applicable” instead of “democrat” or “republican”. Let’s use filter to look at the row that contains the “not applicable” value in the party column: missing_party &lt;- filter(us_data, party == &quot;Not Applicable&quot;) missing_party ## # A tibble: 0 x 6 ## # … with 6 variables: state &lt;chr&gt;, med_income &lt;dbl&gt;, med_prop_val &lt;dbl&gt;, ## # population &lt;dbl&gt;, mean_commute_minutes &lt;dbl&gt;, party &lt;fct&gt; That explains it! That row in the dataset is actually not a US state, but rather the US territory of Peurto Rico. Similar to other US territories, residents of Puerto Rico cannot vote in presidential elections. Hence the “not applicable” label. Let’s remove this row from the data frame and rename the data frame vote_data. To do this, we use the opposite of the equivalency operator (==) for our filter statement, the not equivalent operator (!=). vote_data &lt;- filter(us_data, party != &quot;Not Applicable&quot;) vote_data ## # A tibble: 51 x 6 ## state med_income med_prop_val population mean_commute_minutes party ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 AK 64222 197300 733375 10.5 Republican ## 2 AL 36924 94800 4830620 25.3 Republican ## 3 AR 35833 83300 2958208 22.4 Republican ## 4 AZ 44748 128700 6641928 20.6 Republican ## 5 CA 53075 252100 38421464 23.4 Democrat ## 6 CO 48098 198900 5278906 19.5 Democrat ## 7 CT 69228 246450 3593222 24.3 Democrat ## 8 DC 70848 475800 647484 28.3 Democrat ## 9 DE 54976 228500 926454 24.5 Democrat ## 10 FL 43355 125600 19645772 24.8 Republican ## # … with 41 more rows Now we see that the data frame has 51 rows corresponding to the 50 states and the District of Columbia - all regions where residents can vote in US presidential elections. Let’s now recreate the scatter plot we made above using this data frame subset: ggplot(vote_data, aes(x = med_income, y = med_prop_val, color = party)) + geom_point() + xlab(&quot;Income (USD)&quot;) + ylab(&quot;Median property value (USD)&quot;) What do we see when considering the second part of our exploratory question? Do we see a pattern in how certain states voted in the 2016 Presidential election? We do! Most of the US States who voted for the Republican candidate in the 2016 US Presidential election had lower median household income and lower median property values (data points primarily fall in lower left-hand side of the scatter plot), whereas most of the US states who voted for the Democratic candidate in the 2016 US Presidential election had higher median household income and higher median property values (data points primarily fall in the upper right-hand side of the scatter plot). Does this mean that rich states usually vote for Democrats and poorer states generally vote for Republicans? Or could we use this data visualization on its own to predict which party each state will vote for in the next presidential election? The answer to both these questions is “no.” What we can do with this exploratory data analysis is create new hypotheses, ideas, and questions (like the ones at the beginning of this paragraph). Answering those questions would likely involve gathering additional data and doing more complex analyses, which we will see more of later in this course. 1.6.5 Putting it all together Below, we put everything from this chapter together in one code chunk. This demonstrates the power of R: in relatively few lines of code, we are able to create an entire data science workflow. library(tidyverse) us_data &lt;- read_csv(&quot;state_property_vote.csv&quot;) vote_data &lt;- filter(us_data, party != &quot;Not Applicable&quot;) ggplot(vote_data, aes(x = med_income, y = med_prop_val, color = party)) + geom_point() + xlab(&quot;Income (USD)&quot;) + ylab(&quot;Median property value (USD)&quot;) 1.6.6 What’s next? In the next chapter, we will dig in and spend more time learning how to load spreadsheet-like datasets of various formats into R, as well as how to scrape data from the web! "],
["reading.html", "Chapter 2 Reading in data locally and from the web 2.1 Overview 2.2 Chapter learning objectives 2.3 Absolute and relative file paths 2.4 Reading tabular data from a plain text file into R 2.5 Reading data from an Microsoft Excel file 2.6 Reading data from a database 2.7 Writing data from R to a .csv file 2.8 Scraping data off the web using R 2.9 Additional readings/resources", " Chapter 2 Reading in data locally and from the web 2.1 Overview In this chapter, you’ll learn to read spreadsheet-like data of various formats into R from your local device and from the web. “Reading” (or “loading”) is the process of converting data (stored as plain text, a database, HTML, etc.) into an object (e.g., a dataframe) that R can easily access and manipulate, and is thus the gateway to any data analysis; you won’t be able to analyze data unless you’ve loaded it first. And because there are many ways to store data, there are similarly many ways to read data into R. If you spend more time upfront matching the data reading method to the type of data you have, you will have to spend less time re-formatting, cleaning and wrangling your data (the second step to all data analyses). It’s like making sure your shoelaces are tied well before going for a run so that you don’t trip later on! 2.2 Chapter learning objectives By the end of the chapter, students will be able to: define the following: absolute file path relative file path url read data into R using a relative path and a url compare and contrast the following functions: read_csv read_tsv read_csv2 read_delim read_excel match the following tidyverse read_* function arguments to their descriptions: file delim col_names skip choose the appropriate tidyverse read_* function and function arguments to load a given plain text tabular data set into R use readxl library’s read_excel function and arguments to load a sheet from an excel file into R connect to a database using the DBI library’s dbConnect function list the tables in a database using the DBI library’s dbListTables function create a reference to a database table that is queriable using the tbl from the dbplyr library retrieve data from a database query and bring it into R using the collect function from the dbplyr library (optional) scrape data from the web read/scrape data from an internet URL using the rvest html_nodes and html_text functions compare downloading tabular data from a plain text file (e.g. .csv) from the web versus scraping data from a .html file 2.3 Absolute and relative file paths When you load a data set into R, you first need to tell R where that files lives. The file could live on your computer (local), or somewhere on the internet (remote). In this section we will discuss the case where the file lives on your computer. The place where the file lives on your computer is called the “path”. You can think of the path as directions to the file. There are two kinds of paths: relative paths and absolute paths. A relative path is where the file is in respect to where you currently are on the computer (e.g., where the Jupyter notebook file that you’re working in is). On the other hand, an absolute path is where the file is in respect to the base (or root) folder of the computer’s filesystem. Suppose our computer’s filesystem looks like the picture below, and we are working in the Jupyter notebook titled worksheetk_02.ipynb. If we want to read in the .csv file named happiness_report.csv into our Jupyter notebook using R, we could do this using either a relative or an absolute path. We show what both choices below. Reading happiness_report.csv using a relative path: happiness_data &lt;- read_csv(&quot;data/happiness_report.csv&quot;) Reading happiness_report.csv using an absolute path: happiness_data &lt;- read_csv(&quot;/home/jupyter/dsci-100/worksheet_02/data/happiness_report.csv&quot;) So which one should you use? Generally speaking, to ensure your code can be run on a different computer, you should use relative paths (and it’s also less typing!). This is because the absolute path of a file (the names of folders between the computer’s root / and the file) isn’t usually the same across multiple computers. For example, suppose Alice and Bob are working on a project together on the happiness_report.csv data. Alice’s file is stored at /home/alice/project/data/happiness_report.csv, while Bob’s is stored at /home/bob/project/data/happiness_report.csv. Even though Alice and Bob stored their files in the same place on their computers (in their home folders), the absolute paths are different due to their different usernames. If Bob has code that loads the happiness_report.csv data using an absolute path, the code won’t work on Alice’s computer. But the relative path from inside the project folder (data/happiness_report.csv) is the same on both computers; any code that uses relative paths will work on both! See this video for another explanation: Source: Udacity course “Linux Command Line Basics” 2.4 Reading tabular data from a plain text file into R Now we will learn more about reading tabular data from a plain text file into R, as well as how to write tabular data to a file. Last chapter we learned about using the tidyverse read_csv function when reading files that match that functions expected defaults (column names are present and commas are used as the delimiter/separator between columns). In this section, we will learn how to read files do not satisfy the default expectations of read_csv. Before we jump into the cases where the data aren’t in the expected default format for tidyverse and read_csv, let’s revisit the simpler case where the defaults hold and the only argument we need to give to the function is the path to the file, data/state_property_vote.csv. We put data/ before the name of the file when we are loading the dataset because this dataset is located in a sub-folder, named data, relative to where we are running our R code. Here is what the file would look in a plain text editor: state,med_income,med_prop_val,population,mean_commute_minutes,party AK,64222,197300,733375,10.46830207,Republican AL,36924,94800,4830620,25.30990746,Republican AR,35833,83300,2958208,22.40108933,Republican AZ,44748,128700,6641928,20.58786,Republican CA,53075,252100,38421464,23.38085172,Democrat CO,48098,198900,5278906,19.50792188,Democrat CT,69228,246450,3593222,24.349675,Democrat DC,70848,475800,647484,28.2534,Democrat DE,54976,228500,926454,24.45553333,Democrat And here is a review of how we can use read_csv to load it into R: library(tidyverse) us_data &lt;- read_csv(&quot;data/state_property_vote.csv&quot;) us_data ## # A tibble: 52 x 6 ## state med_income med_prop_val population mean_commute_minutes party ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 AK 64222 197300 733375 10.5 Republican ## 2 AL 36924 94800 4830620 25.3 Republican ## 3 AR 35833 83300 2958208 22.4 Republican ## 4 AZ 44748 128700 6641928 20.6 Republican ## 5 CA 53075 252100 38421464 23.4 Democrat ## 6 CO 48098 198900 5278906 19.5 Democrat ## 7 CT 69228 246450 3593222 24.3 Democrat ## 8 DC 70848 475800 647484 28.3 Democrat ## 9 DE 54976 228500 926454 24.5 Democrat ## 10 FL 43355 125600 19645772 24.8 Republican ## # … with 42 more rows 2.4.1 Skipping rows when reading in data Often times information about how data was collected, or other relevant information, is included at the top of the data file. This information is usually written in sentence and paragraph form, with no delimiter because it is not organized into columns. An example of this is shown below: Data source: https://datausa.io/ Record of how data was collected: https://github.com/UBC-DSCI/introduction-to-datascience/blob/master/data/src/retrieve_data_usa.ipynb Date collected: 2017-06-06 state,med_income,med_prop_val,population,mean_commute_minutes,party AK,64222,197300,733375,10.46830207,Republican AL,36924,94800,4830620,25.30990746,Republican AR,35833,83300,2958208,22.40108933,Republican AZ,44748,128700,6641928,20.58786,Republican CA,53075,252100,38421464,23.38085172,Democrat CO,48098,198900,5278906,19.50792188,Democrat CT,69228,246450,3593222,24.349675,Democrat DC,70848,475800,647484,28.2534,Democrat DE,54976,228500,926454,24.45553333,Democrat Using read_csv as we did previously does not allow us to correctly load the data into R. In the case of this file we end up only reading in one column of the data set: us_data &lt;- read_csv(&quot;data/state_property_vote_meta-data.csv&quot;) ## Parsed with column specification: ## cols( ## `Data source: https://datausa.io/` = col_character() ## ) us_data ## # A tibble: 55 x 1 ## `Data source: https://datausa.io/` ## &lt;chr&gt; ## 1 Record of how data was collected: https://github.com/UBC-DSCI/introduct… ## 2 Date collected: 2017-06-06 ## 3 state ## 4 AK ## 5 AL ## 6 AR ## 7 AZ ## 8 CA ## 9 CO ## 10 CT ## # … with 45 more rows To successfully read data like this into R, the skip argument can be useful to tell R how many lines to skip before it should start reading in the data. In the example above, we would set this value to 3: us_data &lt;- read_csv(&quot;data/state_property_vote_meta-data.csv&quot;, skip = 3) ## Parsed with column specification: ## cols( ## state = col_character(), ## med_income = col_double(), ## med_prop_val = col_double(), ## population = col_double(), ## mean_commute_minutes = col_double(), ## party = col_character() ## ) us_data ## # A tibble: 52 x 6 ## state med_income med_prop_val population mean_commute_minutes party ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 AK 64222 197300 733375 10.5 Republican ## 2 AL 36924 94800 4830620 25.3 Republican ## 3 AR 35833 83300 2958208 22.4 Republican ## 4 AZ 44748 128700 6641928 20.6 Republican ## 5 CA 53075 252100 38421464 23.4 Democrat ## 6 CO 48098 198900 5278906 19.5 Democrat ## 7 CT 69228 246450 3593222 24.3 Democrat ## 8 DC 70848 475800 647484 28.3 Democrat ## 9 DE 54976 228500 926454 24.5 Democrat ## 10 FL 43355 125600 19645772 24.8 Republican ## # … with 42 more rows 2.4.2 read_delim as a more flexible method to get tabular data into R When our tabular data comes in a different format, we can use the read_delim function instead. For example, a different version of this same dataset has no column names and uses tabs as the delimiter instead of commas. Here is how the file would look in a plain text editor: AK 64222 197300 733375 10.46830207 Republican AL 36924 94800 4830620 25.30990746 Republican AR 35833 83300 2958208 22.40108933 Republican AZ 44748 128700 6641928 20.58786 Republican CA 53075 252100 38421464 23.38085172 Democrat CO 48098 198900 5278906 19.50792188 Democrat CT 69228 246450 3593222 24.349675 Democrat DC 70848 475800 647484 28.2534 Democrat DE 54976 228500 926454 24.45553333 Democrat FL 43355 125600 19645772 24.78055522 Republican To get this into R using the read_delim() function, we specify the first argument as the path to the file (as done with read_csv), and then provide values to the delim argument (here a tab, which we represent by &quot;\\t&quot;) and the col_names argument (here we specify that there are no column names be assigning it the value of FALSE). Both read_csv() and read_delim() have a col_names argument and the default is TRUE. us_data &lt;- read_delim(&quot;data/state_property_vote.tsv&quot;, delim = &quot;\\t&quot;, col_names = FALSE) ## Parsed with column specification: ## cols( ## X1 = col_character(), ## X2 = col_double(), ## X3 = col_double(), ## X4 = col_double(), ## X5 = col_double(), ## X6 = col_character() ## ) us_data ## # A tibble: 52 x 6 ## X1 X2 X3 X4 X5 X6 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 AK 64222 197300 733375 10.5 Republican ## 2 AL 36924 94800 4830620 25.3 Republican ## 3 AR 35833 83300 2958208 22.4 Republican ## 4 AZ 44748 128700 6641928 20.6 Republican ## 5 CA 53075 252100 38421464 23.4 Democrat ## 6 CO 48098 198900 5278906 19.5 Democrat ## 7 CT 69228 246450 3593222 24.3 Democrat ## 8 DC 70848 475800 647484 28.3 Democrat ## 9 DE 54976 228500 926454 24.5 Democrat ## 10 FL 43355 125600 19645772 24.8 Republican ## # … with 42 more rows Data frames in R need to have column names, thus if you read data into R as a data frame without column names then R assigns column names for them. If you used the read_* functions to read the data into R, then R gives each column a name of X1, X2, …, XN, where N is the number of columns in the data set. 2.4.3 Reading tabular data directly from a URL We can also use read_csv() or read_delim() (and related functions) to read in tabular data directly from a url that contains tabular data. In this case, we provide the url to read_csv() as the path to the file instead of a path to a local file on our computer. Similar to when we specify a path on our local computer, here we need to surround the url by quotes. All other arguments that we use are the same as when using these functions with a local file on our computer. us_data &lt;- read_csv(&quot;https://raw.githubusercontent.com/UBC-DSCI/introduction-to-datascience/master/state_property_vote.csv&quot;) ## Parsed with column specification: ## cols( ## state = col_character(), ## med_income = col_double(), ## med_prop_val = col_double(), ## population = col_double(), ## mean_commute_minutes = col_double(), ## party = col_character() ## ) us_data ## # A tibble: 52 x 6 ## state med_income med_prop_val population mean_commute_minutes party ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 AK 64222 197300 733375 10.5 Republican ## 2 AL 36924 94800 4830620 25.3 Republican ## 3 AR 35833 83300 2958208 22.4 Republican ## 4 AZ 44748 128700 6641928 20.6 Republican ## 5 CA 53075 252100 38421464 23.4 Democrat ## 6 CO 48098 198900 5278906 19.5 Democrat ## 7 CT 69228 246450 3593222 24.3 Democrat ## 8 DC 70848 475800 647484 28.3 Democrat ## 9 DE 54976 228500 926454 24.5 Democrat ## 10 FL 43355 125600 19645772 24.8 Republican ## # … with 42 more rows 2.4.4 Previewing a data file before reading it into R In all the examples above, we gave you previews of the data file before we read it into R. This is essential so that you can see whether or not there are column names, what the delimiters are, and if there are lines you need to skip. You should do this yourself when trying to read in data files. In Jupyter, you preview data as a plain text file by clicking on the file’s name in the Jupyter home menu. We demonstrate this in the video below: 2.5 Reading data from an Microsoft Excel file There are many other ways to store tabular datasets beyond plain text files, and similarly many ways to load those datasets into R. For example, it is very common to encounter, and need to load into R, data stored as a Microsoft Excel spreadsheet (with the filename extension .xlsx). To be able to do this, a key thing to know is that even though .csv and .xlsx files look almost identical when loaded into Excel, the data themselves are stored completely differently. While .csv files are plain text files, where the characters you see when you open the file in a text editor are exactly the data they represent, this is not the case for .xlsx files. Take a look at what a .xlsx file would look like in a text editor: ,?&#39;O _rels/.rels???J1??&gt;E?{7? &lt;?V????w8?&#39;J???&#39;QrJ???Tf?d??d?o?wZ&#39;?ф??@&gt;?4&#39;?|??hlIo??Fǟ t 8f??3wn ????t??u&quot;/ %~Ed2Ɩ??&lt;?w?? ?Pd(??J-?E???7?&#39;t(?-GZ?????y?ߎ??c~N?g[^_r?4 yG?O ?K??G?RPX?&lt;??,?&#39;O[Content_Types].xml???n?0E%?J ]TUE袏e??O??c[???????6q??s??d?m???ƻ\\???H?^????3} ?rZY? ?:L60?^?????XTP+?|?3???&quot;~?3T1W3???ޓ,?#p?R?!??w(??R???[S?D?kP?P!XS(?i?t?$?ei оX?ܒa??4VT?,D?Jq D ?????u?]??;??L?.8AhfNv}߼?hHF*җ??Jr?Q?%?g?U??CtX&quot;8x&gt;?.|????5j?/$???JE?c??~ݜ??4iw?????E;?+?S??w?cV+?:???2l???=?2nݡl?????;|?V??????c&#39;?????9?P&amp;Bcj,?&#39;OdocProps/app.xml??1 ?0???k????A?u?U?]ȝ??{#?:;/&lt;?g?Cߩd????M+?=???Z?O??R+??u?P?X?̔ KV@??M$??a???d,??_???4??5v?R????9D????t??Fk?Ú&#39;P?=?,?&#39;OdocProps/core.xml??MO?0 ??J?{???3j?h&#39;??(q??U4J ??=i?I&#39;?b??[v?ޙ!??{gk? F2????v5yj7??&quot;J???,?d???J???C??ƚl??4?-?$ۤ??`$?4t?K?.;?%c?J-Q҉??G&lt;??ɑZ-H???? X????z???6?????~q??X??ٗ6?????q^&gt;??tH???*?D???M?g ??D?????????ݐ?d?:g).ے?3.??׉uԟ?ǟj?P?F؝,?&#39;Oxl/_rels/workbook.xml.rels??Ak1??J?{7???R?^J?kk@Hf7??I?L???E]A?Þ?{a??`f?????b?6xUQ?@o?m}??o????X{???Q?????;?y?\\? O ?YY??4΀?L??S??k?252j?? ??V ?C?g?C]??????? ? ???E??TENyf6% ?Y????|??:%???}^ N?Q?ۤ?N&#39;????)??F?\\??P?G??,?&#39;O&#39;xl/printerSettings/printerSettings1.bin?Wmn? ??Sp&gt;?G???q?# ?I??ڒ5R&#39;???q????(?L ??m??8F?5&lt; L`?ݍ-?`?A??2{dp??9R#?&gt;7??Xu???ꋝ/?X??HI?|? ??r)???\\?VA8?2dFfq???I]]o 5`??&lt;͘??6uA ? This type of file representation allows Excel files to store additional things that you cannot store in a .csv file, such as fonts, text formatting, graphics, multiple sheets and more. And despite looking odd in a plain text editor, we can read Excel spreadsheets into R using the readxl package developed specifically for this purpose. library(readxl) us_data &lt;- read_excel(&quot;data/state_property_vote.xlsx&quot;) us_data ## # A tibble: 52 x 6 ## state med_income med_prop_val population mean_commute_minutes party ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 AK 64222 197300 733375 10.5 Republican ## 2 AL 36924 94800 4830620 25.3 Republican ## 3 AR 35833 83300 2958208 22.4 Republican ## 4 AZ 44748 128700 6641928 20.6 Republican ## 5 CA 53075 252100 38421464 23.4 Democrat ## 6 CO 48098 198900 5278906 19.5 Democrat ## 7 CT 69228 246450 3593222 24.3 Democrat ## 8 DC 70848 475800 647484 28.3 Democrat ## 9 DE 54976 228500 926454 24.5 Democrat ## 10 FL 43355 125600 19645772 24.8 Republican ## # … with 42 more rows If the .xlsx file has multiple sheets, then you have to use the sheet argument to specify either the sheet number or name. You can also specify cell ranges using the range argument. This is useful in cases where a single sheet contains multiple tables (a sad thing that happens to many Excel spreadsheets). As with plain text files, you should always try to explore the data file before importing it into R. This helps you decide which arguments you need to use to successfully load the data into R. If you do not have the Excel program on your computer, there are other free programs you can use to preview the file. Examples include Google Sheets and Libre Office. 2.6 Reading data from a database Another very common form of data storage to be read into R for the purpose of data analysis is the relational database. There are many relational database management systems, such as SQLite, MySQL, PosgreSQL, Oracle, and many more. Almost all employ SQL (structured query language) to pull data from the database. Thankfully, you don’t need to know SQL to analyze data from a database; several packages have been written that allow R to connect to relational databases and use the R programming language as the front end (what the user types in) to pull data from them. In this book we will give examples of how to do this using R with SQLite and PostgreSQL databases. 2.6.1 Reading data from a SQLite database SQLite is probably the simplest relational database that one can use in combination with R. SQLite databases are self-contained and usually stored and accessed locally on one computer. Data is usually stored in a file with a .db extension. Similar to Excel files, these are not plain text files and cannot be read in a plain text editor. The first thing you need to do to read data into R from a database is to connect to the database. We do that using the dbConnect function from the DBI (database interface) package. This does not read in the data, but simply tells R where the database is and opens up a communication channel. library(DBI) con_state_data &lt;- dbConnect(RSQLite::SQLite(), &quot;data/state_property_vote.db&quot;) Often times relational databases have many tables, and their power comes from the useful ways they can be joined. Thus anytime you want to access data from a relational database you need to know the table names. You can get the names of all the tables in the database using the dbListTables function: tables &lt;- dbListTables(con_state_data) tables ## [1] &quot;state&quot; We only get one table name returned form calling dbListTables, and this tells us that there is only one table in this database. To reference a table in the database so we can do things like select columns and filter rows, we use the tbl function from the dbplyr package: library(dbplyr) state_db &lt;- tbl(con_state_data, &quot;state&quot;) state_db ## # Source: table&lt;state&gt; [?? x 6] ## # Database: sqlite 3.29.0 ## # [/Users/tiffany/Documents/ubc-dsci/introduction-to-datascience/data/state_property_vote.db] ## state med_income med_prop_val population mean_commute_minutes party ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 AK 64222 197300 733375 10.5 Republican ## 2 AL 36924 94800 4830620 25.3 Republican ## 3 AR 35833 83300 2958208 22.4 Republican ## 4 AZ 44748 128700 6641928 20.6 Republican ## 5 CA 53075 252100 38421464 23.4 Democrat ## 6 CO 48098 198900 5278906 19.5 Democrat ## 7 CT 69228 246450 3593222 24.3 Democrat ## 8 DC 70848 475800 647484 28.3 Democrat ## 9 DE 54976 228500 926454 24.5 Democrat ## 10 FL 43355 125600 19645772 24.8 Republican ## # … with more rows Although it looks like we just got a data frame from the database, we didn’t! It’s a reference, showing us data that is still in the SQLite database (note the first two lines of the output). It does this because databases are often more efficient at selecting, filtering and joining large datasets than R. And typically, the database will not even be stored on your computer, but rather a more powerful machine somewhere on the web. So R is lazy and waits to bring this data into memory until you explicitly tell it to do so using the collect function from the dbplyr library. Here we will filter for only states that voted for the Republican candidate in the 2016 Presidential election, and then use collect to finally bring this data into R as a data frame. republican_db &lt;- filter(state_db, party == &quot;Republican&quot;) republican_db ## # Source: lazy query [?? x 6] ## # Database: sqlite 3.29.0 ## # [/Users/tiffany/Documents/ubc-dsci/introduction-to-datascience/data/state_property_vote.db] ## state med_income med_prop_val population mean_commute_minutes party ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 AK 64222 197300 733375 10.5 Republican ## 2 AL 36924 94800 4830620 25.3 Republican ## 3 AR 35833 83300 2958208 22.4 Republican ## 4 AZ 44748 128700 6641928 20.6 Republican ## 5 FL 43355 125600 19645772 24.8 Republican ## 6 GA 37865 101700 10006693 24.5 Republican ## 7 IA 49448 102700 3093526 18.4 Republican ## 8 ID 43080. 143900 1616547 19.9 Republican ## 9 IN 47194 111800 6568645 23.5 Republican ## 10 KS 46875 85200 2892987 16.7 Republican ## # … with more rows republican_data &lt;- collect(republican_db) republican_data ## # A tibble: 31 x 6 ## state med_income med_prop_val population mean_commute_minutes party ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 AK 64222 197300 733375 10.5 Republican ## 2 AL 36924 94800 4830620 25.3 Republican ## 3 AR 35833 83300 2958208 22.4 Republican ## 4 AZ 44748 128700 6641928 20.6 Republican ## 5 FL 43355 125600 19645772 24.8 Republican ## 6 GA 37865 101700 10006693 24.5 Republican ## 7 IA 49448 102700 3093526 18.4 Republican ## 8 ID 43080. 143900 1616547 19.9 Republican ## 9 IN 47194 111800 6568645 23.5 Republican ## 10 KS 46875 85200 2892987 16.7 Republican ## # … with 21 more rows Why bother to use the collect function? The data looks pretty similar in both outputs shown above. And dbplyr provides lots of functions similar to filter that you can use to directly feed the database reference (what tbl gives you) into downstream analysis functions (e.g., ggplot2 for data visualization and lm for linear regression modeling). However, this does not work in every case; look what happens when we try to use nrow to count rows in a data frame: nrow(republican_db) ## [1] NA or tail to preview the last 6 rows of a data frame: tail(republican_db) ## Error: tail() is not supported by sql sources Additionally, some operations will not work to extract columns or single values from the reference given by the tbl function. Thus, once you have finished your data wrangling of the tbl database reference object, it is advisable to then bring it into your local machine’s memory using collect as a data frame. 2.6.2 Reading data from a PostgreSQL database PostgreSQL (also called Postgres) is a very popular free and open-source option for relational database software. Unlike SQLite, PostgreSQL uses a client–server database engine, as it was designed to be used and accessed on a network. This means that you have to provide more information to R when connecting to Postgres databases. The additional information that you need to include when you call the dbConnect function is listed below: dbname - the name of the database (a single PostgreSQL instance can host more than one database) host - the URL pointing to where the database is located port - the communication endpoint between R and the PostgreSQL database (this is typically 5432 for PostgreSQL) user - the username for accessing the database password - the password for accessing the database Additionally, we must use the RPostgres library instead of RSQLite in the dbConnect function call. Below we demonstrate how to connect to a version of the can_mov_db database, which contains information about Canadian movies (note - this is a synthetic, or artificial, database). library(RPostgres) can_mov_db_con &lt;- dbConnect(RPostgres::Postgres(), dbname = &quot;can_mov_db&quot;, host = &quot;r7k3-mds1.stat.ubc.ca&quot;, port = 5432, user = &quot;user0001&quot;, password = &#39;################&#39;) After opening the connection, everything looks and behaves almost identically to when we were using an SQLite database in R. For example, we can again use dbListTables to find out what tables are in the can_mov_db database: dbListTables(can_mov_db_con) [1] &quot;themes&quot; &quot;medium&quot; &quot;titles&quot; &quot;title_aliases&quot; &quot;forms&quot; [6] &quot;episodes&quot; &quot;names&quot; &quot;names_occupations&quot; &quot;occupation&quot; &quot;ratings&quot; We see that there are 10 tables in this database. Let’s first look at the &quot;ratings&quot; table to find the lowest rating that exists in the can_mov_db database: ratings_db &lt;- tbl(can_mov_db_con, &quot;ratings&quot;) ratings_db # Source: table&lt;ratings&gt; [?? x 3] # Database: postgres [user0001@r7k3-mds1.stat.ubc.ca:5432/can_mov_db] title average_rating num_votes &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; 1 The Grand Seduction 6.6 150 2 Rhymes for Young Ghouls 6.3 1685 3 Mommy 7.5 1060 4 Incendies 6.1 1101 5 Bon Cop, Bad Cop 7.0 894 6 Goon 5.5 1111 7 Monsieur Lazhar 5.6 610 8 What if 5.3 1401 9 The Barbarian Invations 5.8 99 10 Away from Her 6.9 2311 # … with more rows To find the lowest rating that exists in the data base, we first need to extract the average_rating column using select: avg_rating_db &lt;- select(ratings_db, average_rating) avg_rating_db # Source: lazy query [?? x 1] # Database: postgres [user0001@r7k3-mds1.stat.ubc.ca:5432/can_mov_db] average_rating &lt;dbl&gt; 1 6.6 2 6.3 3 7.5 4 6.1 5 7.0 6 5.5 7 5.6 8 5.3 9 5.8 10 6.9 # … with more rows Next we use min to find the minimum rating in that column: min(avg_rating_db) Error in min(avg_rating_db) : invalid &#39;type&#39; (list) of argument Instead of the minimum, we get an error! This is another example of when we need to use the collect function to bring the data into R for further computation: avg_rating_data &lt;- collect(avg_rating_db) min(avg_rating_data) [1] 1 We see the lowest rating given to a movie is 1, indicating that it must have been a really bad movie… 2.7 Writing data from R to a .csv file At the middle and end of a data analysis, we often want to write a data frame that has changed (either through filtering, selecting, mutating or summarizing) to a file so that we can share it with others or use it for another step in the analysis. The most straightforward way to do this is to use the write_csv function from the tidyverse library. The default arguments for this file are to use a comma (,) as the delimiter and include column names. Below we demonstrate creating a new version of the US state-level property, income, population and voting data from 2015 and 2016 that does not contain the territory of Puerto Rico, and then writing this to a .csv file: state_data &lt;- filter(us_data, state != &quot;PR&quot;) write_csv(state_data, &quot;data/us_states_only.csv&quot;) 2.8 Scraping data off the web using R In the first part of this chapter we learned how to read in data from plain text files that are usually “rectangular” in shape using the tidyverse read_* functions. Sadly, not all data comes in this simple format, but happily there are many other tools we can use to read in more messy/wild data formats. One common place people often want/need to read in data from is websites. Such data exists in an a non-rectangular format. One quick and easy solution to get this data is to copy and paste it, however this becomes painstakingly long and boring when there is a lot of data that needs gathering, and anytime you start doing a lot of copying and pasting it is very likely you will introduce errors. The formal name for gathering non-rectangular data from the web and transforming it into a more useful format for data analysis is web scraping. There are two different ways to do web scraping: 1) screen scraping (similar to copying and pasting from a website, but done in a programmatic way to minimize errors and maximize efficiency) and 2) web APIs (application programming interface) (a website that provides a programatic way of returning the data as JSON or XML files via http requests). In this course we will explore the first method, screen scraping using R’s rvest package. 2.8.1 HTML and CSS selectors Before we jump into scraping, let’s set up some motivation and learn a little bit about what the “source code” of a website looks like. Say we are interested in knowing the average rental price (per square footage) of the most recently available 1 bedroom apartments in Vancouver from https://vancouver.craigslist.org. When we visit the Vancouver Craigslist website and search for 1 bedroom apartments, this is what we are shown: From that page, it’s pretty easy for our human eyes to find the apartment price and square footage. But how can we do this programmatically so we don’t have to copy and paste all these numbers? Well, we have to deal with the webpage source code, which we show a snippet of below (and link to the entire source code here): &lt;span class=&quot;result-meta&quot;&gt; &lt;span class=&quot;result-price&quot;&gt;$800&lt;/span&gt; &lt;span class=&quot;housing&quot;&gt; 1br - &lt;/span&gt; &lt;span class=&quot;result-hood&quot;&gt; (13768 108th Avenue)&lt;/span&gt; &lt;span class=&quot;result-tags&quot;&gt; &lt;span class=&quot;maptag&quot; data-pid=&quot;6786042973&quot;&gt;map&lt;/span&gt; &lt;/span&gt; &lt;span class=&quot;banish icon icon-trash&quot; role=&quot;button&quot;&gt; &lt;span class=&quot;screen-reader-text&quot;&gt;hide this posting&lt;/span&gt; &lt;/span&gt; &lt;span class=&quot;unbanish icon icon-trash red&quot; role=&quot;button&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;a href=&quot;#&quot; class=&quot;restore-link&quot;&gt; &lt;span class=&quot;restore-narrow-text&quot;&gt;restore&lt;/span&gt; &lt;span class=&quot;restore-wide-text&quot;&gt;restore this posting&lt;/span&gt; &lt;/a&gt; &lt;/span&gt; &lt;/p&gt; &lt;/li&gt; &lt;li class=&quot;result-row&quot; data-pid=&quot;6788463837&quot;&gt; &lt;a href=&quot;https://vancouver.craigslist.org/nvn/apa/d/north-vancouver-luxury-1-bedroom/6788463837.html&quot; class=&quot;result-image gallery&quot; data-ids=&quot;1:00U0U_lLWbuS4jBYN,1:00T0T_9JYt6togdOB,1:00r0r_hlMkwxKqoeq,1:00n0n_2U8StpqVRYX,1:00M0M_e93iEG4BRAu,1:00a0a_PaOxz3JIfI,1:00o0o_4VznEcB0NC5,1:00V0V_1xyllKkwa9A,1:00G0G_lufKMygCGj6,1:00202_lutoxKbVTcP,1:00R0R_cQFYHDzGrOK,1:00000_hTXSBn1SrQN,1:00r0r_2toXdps0bT1,1:01616_dbAnv07FaE7,1:00g0g_1yOIckt0O1h,1:00m0m_a9fAvCYmO9L,1:00C0C_8EO8Yl1ELUi,1:00I0I_iL6IqV8n5MB,1:00b0b_c5e1FbpbWUZ,1:01717_6lFcmuJ2glV&quot;&gt; &lt;span class=&quot;result-price&quot;&gt;$2285&lt;/span&gt; &lt;/a&gt; &lt;p class=&quot;result-info&quot;&gt; &lt;span class=&quot;icon icon-star&quot; role=&quot;button&quot;&gt; &lt;span class=&quot;screen-reader-text&quot;&gt;favorite this post&lt;/span&gt; &lt;/span&gt; &lt;time class=&quot;result-date&quot; datetime=&quot;2019-01-06 12:06&quot; title=&quot;Sun 06 Jan 12:06:01 PM&quot;&gt;Jan 6&lt;/time&gt; &lt;a href=&quot;https://vancouver.craigslist.org/nvn/apa/d/north-vancouver-luxury-1-bedroom/6788463837.html&quot; data-id=&quot;6788463837&quot; class=&quot;result-title hdrlnk&quot;&gt;Luxury 1 Bedroom CentreView with View - Lonsdale&lt;/a&gt; This is not easy for our human eyeballs to read! However, it is easy for us to use programmatic tools to extract the data we need by specifying which HTML tags (things inside &lt; and &gt; in the code above). For example, if we look in the code above and search for lines with a price, we can also look at the tags that are near that price and see if there’s a common “word” we can use that is near the price but doesn’t exist on other lines that have information we are not interested in: &lt;span class=&quot;result-price&quot;&gt;$800&lt;/span&gt; and &lt;span class=&quot;result-price&quot;&gt;$2285&lt;/span&gt; What we can see is there is a special “word” here, “result-price”, which appears only on the lines with prices and not on the other lines (that have information we are not interested in). This special word and the context in which is is used (learned from the other words inside the HTML tag) can be combined to create something called a CSS selector. The CSS selector can then be used by R’s rvest package to select the information we want (here price) from the website source code. Now, many websites are quite large and complex, and so then is their website source code. And as you saw above, it is not easy to read and pick out the special words we want with our human eyeballs. So to make this easier, we will use the SelectorGadget tool. It is an open source tool that simplifies generating and finding CSS selectors. We recommend you use the Chrome web browser to use this tool, and install the selector gadget tool from the Chrome Web Store. Here is a short video on how to install and use the SelectorGadget tool to get a CSS selector for use in web scraping: From installing and using the selectorgadget as shown in the video above, we get the two CSS selectors .housing and .result-price that we can use to scrape information about the square footage and the rental price, respectively. The selector gadget returns them to us as a comma separated list (here .housing , .result-price), which is exactly the format we need to provide to R if we are using more than one CSS selector. 2.8.2 Are you allowed to scrape that website? BEFORE scraping data from the web, you should always check whether or not you are ALLOWED to scrape it! There are two documents that are important for this: the robots.txt file and reading the website’s Terms of Service document. The website’s Terms of Service document is probably the more important of the two, and so you should look there first. What happens when we look at Craigslist’s Terms of Service document? Well we read this: “You agree not to copy/collect CL content via robots, spiders, scripts, scrapers, crawlers, or any automated or manual equivalent (e.g., by hand).” source: https://www.craigslist.org/about/terms.of.use Want to learn more about the legalities of web scraping and crawling? Read this interesting blog post titled “Web Scraping and Crawling Are Perfectly Legal, Right?” by Benoit Bernard (this is optional, not required reading). So what to do now? Well, we shouldn’t scrape Craigslist! Let’s instead scrape some data on the population of Canadian cities from Wikipedia (who’s Terms of Service document does not explicilty say do not scrape). In this video below we demonstrate using the selectorgadget tool to get CSS Selectors from Wikipedia’s Canada page to scrape a table that contains city names and their populations from the 2016 Canadian Census: 2.8.3 Using rvest Now that we have our CSS selectors we can use rvest R package to scrape our desired data from the website. First we start by loading the rvest package: library(rvest) library(rvest) gives error… If you get an error about R not being able to find the package (e.g., Error in library(rvest) : there is no package called ‘rvest’) this is likely because it was not installed. To install the rvest package, run the following command once inside R (and then delete that line of code): install.packages(&quot;rvest&quot;). Next, we tell R what page we want to scrape by providing the webpage’s URL in quotations to the function read_html: page &lt;- read_html(&quot;https://en.wikipedia.org/wiki/Canada&quot;) Then we send the page object to the html_nodes function. We also provide that function with the CSS selectors we obtained from the selectorgadget tool. These should be surrounded by quotations. The html_nodes function select nodes from the HTML document using CSS selectors. nodes are the HTML tag pairs as well as the content between the tags. For our CSS selector td:nth-child(5) and example node that would be selected would be: &lt;td style=&quot;text-align:left;background:#f0f0f0;&quot;&gt;&lt;a href=&quot;/wiki/London,_Ontario&quot; title=&quot;London, Ontario&quot;&gt;London&lt;/a&gt;&lt;/td&gt; population_nodes &lt;- html_nodes(page, &quot;td:nth-child(5) , td:nth-child(7) , .infobox:nth-child(122) td:nth-child(1) , .infobox td:nth-child(3)&quot;) head(population_nodes) ## {xml_nodeset (6)} ## [1] &lt;td style=&quot;text-align:right;&quot;&gt;5,928,040&lt;/td&gt; ## [2] &lt;td style=&quot;text-align:left;background:#f0f0f0;&quot;&gt;&lt;a href=&quot;/wiki/Londo ... ## [3] &lt;td style=&quot;text-align:right;&quot;&gt;494,069\\n&lt;/td&gt; ## [4] &lt;td style=&quot;text-align:right;&quot;&gt;4,098,927&lt;/td&gt; ## [5] &lt;td style=&quot;text-align:left;background:#f0f0f0;&quot;&gt;\\n&lt;a href=&quot;/wiki/St. ... ## [6] &lt;td style=&quot;text-align:right;&quot;&gt;406,074\\n&lt;/td&gt; Next we extract the meaningful data from the HTML nodes using the html_text function. For our example, this functions only required argument is the an html_nodes object, which we named rent_nodes. In the case of this example node: &lt;td style=&quot;text-align:left;background:#f0f0f0;&quot;&gt;&lt;a href=&quot;/wiki/London,_Ontario&quot; title=&quot;London, Ontario&quot;&gt;London&lt;/a&gt;&lt;/td&gt;, the html_text function would return London. population_text &lt;- html_text(population_nodes) head(population_text) ## [1] &quot;5,928,040&quot; &quot;London&quot; ## [3] &quot;494,069\\n&quot; &quot;4,098,927&quot; ## [5] &quot;St. Catharines–Niagara&quot; &quot;406,074\\n&quot; Are we done? Not quite… If you look at the data closely you see that the data is not in an optimal format for data analysis. Both the city names and population are encoded as characters in a single vector instead of being in a data frame with one character column for city and one numeric column for population (think of how you would organize the data in a spreadsheet). Additionally, the populations contain commas (not useful for programmatically dealing with numbers), and some even contain a line break character at the end (\\n). Next chapter we will learn more about data wrangling using R so that we can easily clean up this data with a few lines of code. 2.9 Additional readings/resources Data import chapter from R for Data Science by Garrett Grolemund &amp; Hadley Wickham "],
["wrangling.html", "Chapter 3 Cleaning and wrangling data 3.1 Overview 3.2 Chapter learning objectives 3.3 Vectors and Data frames 3.4 Tidy Data 3.5 Combining functions using the pipe operator, %&gt;%: 3.6 Iterating over data with group_by + summarize 3.7 Additional reading on the dplyr functions 3.8 Using purrr’s map* functions to iterate 3.9 Additional readings/resources", " Chapter 3 Cleaning and wrangling data 3.1 Overview This chapter will be centered around tools for cleaning and wrangling data that move data from its raw format into a format that is suitable for data analysis. They will be presented in the context of a real world data science application, providing more practice working through a whole case study. 3.2 Chapter learning objectives By the end of the chapter, students will be able to: define the term “tidy data” discuss the advantages and disadvantages from storing data in a tidy data format recall and use the following tidyverse functions and operators for their intended data wrangling tasks: select filter %&gt;% map mutate summarize group_by gather separate %in% 3.3 Vectors and Data frames At this point, we know how to load data into R from various file formats. Once loaded into R, all the tools we have learned about for reading data into R represent the data as a data frame. So now we will spend some time learning more about data frames in R, such that we have a better understanding of how we can use and manipulate these objects. 3.3.1 What is a data frame? Let’s first start by defining exactly what a data frame is. From a data perspective, it is a rectangle where the rows are the observations: and the columns are the variables: From a computer programming perspective, in R, a data frame is a special subtype of a list object whose elements (columns) are vectors. For example, the data frame below has 3 elements that are vectors whose names are state, year and population. 3.3.2 What is a vector? In R, vectors are objects that can contain 1 or more elements. The vector elements are ordered, and they must all be of the same type. Common example types of vectors are character (e.g., letter or words), numeric (whole numbers and fractions) and logical (e.g., TRUE or FALSE). In the vector shown below, the elements are of numeric type: 3.3.3 How are vectors different from a list? Lists are also objects in R that have multiple elements. Vectors and lists differ by the requirement of element type consistency. All elements within a single vector must be of the same type (e.g., all elements are numbers), whereas elements within a single list can be of different types (e.g., characters, numbers, logicals and even other lists can be elements in the same list). 3.3.4 What does this have to do with data frames? As mentioned earlier, a data frame is really a special type of list where the elements can only be vectors. Representing data with such an object enables us to easily work with our data in a rectangular/spreadsheet like manner, and to have columns/vectors of different characteristics associated/linked in one object. This is similar to a table in a spreadsheet or a database. 3.4 Tidy Data There are many ways spreadsheet-like dataset can be organized. In this chapter we are going to focus on the tidy data format of organization, and how to make your raw (and likely messy) data tidy. This is because a variety of tools we would like to be able to use in R are designed to work most effectively (and efficiently) with tidy data. 3.4.1 What is tidy data? Tidy data satisfy the following three criteria: each row is a single observation, each column is a single variable, and each value is a single cell (i.e., its row and column position in the data frame is not shared with another value) image source: R for Data Science by Garrett Grolemund &amp; Hadley Wickham Definitions to know: observation - all of the quantities or a qualities we collect from a given entity/object variable - any characteristic, number, or quantity that can be measured or collected value - a single collected quantity or a quality from a given entity/object 3.4.2 Why is tidy data important in R? First, one of the most popular plotting toolsets in R, the ggplot2 library, expects the data to be in a tidy format. Second, most statistical analysis functions expect data in tidy format. Given that both of these tasks are central in virtually any data analysis project, it is well worth spending the time to get your data into a tidy format up front. Luckily there are many well designed tidyverse data cleaning/wrangling tools to help you easily tidy your data. Let’s explore them now! 3.4.3 Going from wide to long (or tidy!) using gather One common thing that often has to be done to get data into a tidy format is to combine columns that are really part the same variable but currently stored in separate columns. To do this we can use the function gather. gather acts to combine columns, and thus makes the data frame narrower. Data is often stored in a wider, not tidy, format because this format is often more intuitive for human readability and understanding, and humans create data sets. An example of this is shown below: library(tidyverse) hist_vote_wide &lt;- read_csv(&quot;data/historical_vote_wide.csv&quot;) hist_vote_wide ## # A tibble: 10 x 3 ## election_year winner runnerup ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2016 Donald Trump Hillary Clinton ## 2 2012 Barack Obama Mitt Romney ## 3 2008 Barack Obama John McCain ## 4 2004 George Bush John Kerry ## 5 2000 George Bush Al Gore ## 6 1996 Bill Clinton Bob Dole ## 7 1992 Bill Clinton George Bush ## 8 1988 George Bush Michael Dukakis ## 9 1984 Ronald Reagan Walter Mondale ## 10 1980 Ronald Reagan Jimmy Carter What is wrong with our untidy format above? From a data analysis perspective, this format is not ideal because in this format the outcome of the variable “result” (winner or runner up) is stored as column names and not easily accessible for the data analysis functions we will want to apply to our data set. Additionally, the values of the “candidate” variable are spread across two columns and will require some sort of binding or joining to get them into one single column to allow us to do our desired visualization and statistical tasks later on. To accomplish this data tranformation we will use the tidyverse function gather. To use gather we need to specify: the dataset the key: the name of a new column that will be created, whose values will come from the names of the columns that we want to combine (the result argument) the value: the name of a new column that will be created, whose values will come from the values of the columns we want to combine (the value argument) the names of the columns that we want to combine (we list these after specifying the key and value, and separate the column names with commas) For the above example, we use gather to combine the winner and runnerup columns into a single column called candidate, and create a column called result that contains the outcome of the election for each candidate: hist_vote_tidy &lt;- gather(hist_vote_wide, key = result, value = candidate, winner, runnerup) hist_vote_tidy ## # A tibble: 20 x 3 ## election_year result candidate ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2016 winner Donald Trump ## 2 2012 winner Barack Obama ## 3 2008 winner Barack Obama ## 4 2004 winner George Bush ## 5 2000 winner George Bush ## 6 1996 winner Bill Clinton ## 7 1992 winner Bill Clinton ## 8 1988 winner George Bush ## 9 1984 winner Ronald Reagan ## 10 1980 winner Ronald Reagan ## 11 2016 runnerup Hillary Clinton ## 12 2012 runnerup Mitt Romney ## 13 2008 runnerup John McCain ## 14 2004 runnerup John Kerry ## 15 2000 runnerup Al Gore ## 16 1996 runnerup Bob Dole ## 17 1992 runnerup George Bush ## 18 1988 runnerup Michael Dukakis ## 19 1984 runnerup Walter Mondale ## 20 1980 runnerup Jimmy Carter Splitting code across lines: In the code above, the call to the gather function is split across several lines. This is allowed and encouraged when programming in R when your code line gets too long to read clearly. When doing this, it is important to end the line with a comma , so that R knows the function should continue to the next line.* The data above is now tidy because all 3 criteria for tidy data have now been met: All the variables (candidate and result) are now their own columns in the data frame. Each observation, i.e., each candidate’s name, result, and candidacy year, are in a single row. Each value is a single cell, i.e., its row, column position in the data frame is not shared with another value. 3.4.4 Using separate to deal with multiple delimiters As discussed above, data are also not considered tidy when multiple values are stored in the same cell. In addition to the previous untidiness we addressed in the earlier version of this data set, the one we show below is even messier: the winner and runnerup columns contain both the candidate’s name as well as their political party. To make this messy data tidy we’ll have to fix both of these issues. hist_vote_party &lt;- read_csv(&quot;data/historical_vote_messy.csv&quot;) hist_vote_party ## # A tibble: 10 x 3 ## election_year winner runnerup ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2016 Donald Trump/Rep Hillary Clinton/Dem ## 2 2012 Barack Obama/Dem Mitt Romney/Rep ## 3 2008 Barack Obama/Dem John McCain/Rep ## 4 2004 George W Bush/Rep John Kerry/Dem ## 5 2000 George W Bush/Rep Al Gore/Dem ## 6 1996 Bill Clinton/Dem Bob Dole/Rep ## 7 1992 Bill Clinton/Dem George HW Bush/Rep ## 8 1988 George HW Bush/Rep Michael Dukakis/Dem ## 9 1984 Ronald Reagan/Rep Walter Mondale/Dem ## 10 1980 Ronald Reagan/Rep Jimmy Carter/Dem First we’ll use gather to create the result and candidate columns, as we did previously: hist_vote_party_gathered &lt;- gather(hist_vote_party, key = result, value = candidate, winner, runnerup) hist_vote_party_gathered ## # A tibble: 20 x 3 ## election_year result candidate ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2016 winner Donald Trump/Rep ## 2 2012 winner Barack Obama/Dem ## 3 2008 winner Barack Obama/Dem ## 4 2004 winner George W Bush/Rep ## 5 2000 winner George W Bush/Rep ## 6 1996 winner Bill Clinton/Dem ## 7 1992 winner Bill Clinton/Dem ## 8 1988 winner George HW Bush/Rep ## 9 1984 winner Ronald Reagan/Rep ## 10 1980 winner Ronald Reagan/Rep ## 11 2016 runnerup Hillary Clinton/Dem ## 12 2012 runnerup Mitt Romney/Rep ## 13 2008 runnerup John McCain/Rep ## 14 2004 runnerup John Kerry/Dem ## 15 2000 runnerup Al Gore/Dem ## 16 1996 runnerup Bob Dole/Rep ## 17 1992 runnerup George HW Bush/Rep ## 18 1988 runnerup Michael Dukakis/Dem ## 19 1984 runnerup Walter Mondale/Dem ## 20 1980 runnerup Jimmy Carter/Dem Then we’ll use separate to split the candidate column into two columns, one that contains only the candidate’s name (“candidate”), and one that contains a short identifier for which political party the candidate belonged to (“party”): hist_vote_party_tidy &lt;- separate(hist_vote_party_gathered, col = candidate, into = c(&quot;candidate&quot;, &quot;party&quot;), sep = &quot;/&quot;) hist_vote_party_tidy ## # A tibble: 20 x 4 ## election_year result candidate party ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2016 winner Donald Trump Rep ## 2 2012 winner Barack Obama Dem ## 3 2008 winner Barack Obama Dem ## 4 2004 winner George W Bush Rep ## 5 2000 winner George W Bush Rep ## 6 1996 winner Bill Clinton Dem ## 7 1992 winner Bill Clinton Dem ## 8 1988 winner George HW Bush Rep ## 9 1984 winner Ronald Reagan Rep ## 10 1980 winner Ronald Reagan Rep ## 11 2016 runnerup Hillary Clinton Dem ## 12 2012 runnerup Mitt Romney Rep ## 13 2008 runnerup John McCain Rep ## 14 2004 runnerup John Kerry Dem ## 15 2000 runnerup Al Gore Dem ## 16 1996 runnerup Bob Dole Rep ## 17 1992 runnerup George HW Bush Rep ## 18 1988 runnerup Michael Dukakis Dem ## 19 1984 runnerup Walter Mondale Dem ## 20 1980 runnerup Jimmy Carter Dem Is this data now tidy? Well, if we recall the 3 criteria for tidy data: each row is a single observation, each column is a single variable, and each value is a single cell. We can see that this data now satifies all 3 criteria, making it easier to analyze. For example, we could visualize the number of winning candidates for each party over this time span: ggplot(hist_vote_party_tidy, aes(x = result, fill = party)) + geom_bar() + scale_fill_manual(values=c(&quot;blue&quot;, &quot;red&quot;)) + xlab(&quot;US Presidential election result&quot;) + ylab(&quot;Number of US Presidential candidates&quot;) + ggtitle(&quot;US Presidential candidates (1980 - 2016)&quot;) From this visualization, we can see that between 1980 - 2016 (inclusive) the Republican party has won more US Presidential elections than the Democratic party. 3.4.5 Notes on defining tidy data Is there only one shape for tidy data for a given data set? Not necessarily, it depends on the statistical question you are asking and what the variables are for that question. For tidy data, each variable should be its own column. So just as its important to match your statistical question with the appropriate data analysis tool (classification, clustering, hypothesis testing, etc). It’s important to match your statistical question with the appropriate variables and ensure they are each represented as individual columns to make the data tidy. 3.5 Combining functions using the pipe operator, %&gt;%: In R, we often have to call multiple functions in a sequence to process a data frame. The basic ways of doing this can become quickly unreadable if there are many steps. For example, suppose we need to perform three operations on a data frame data: add a new column new_col that is double another old_col filter for rows where another column, other_col, is more than 5, and select only the new column new_col for those rows. One way of doing is to just write multiple lines of code, storing temporary objects as you go: output_1 &lt;- mutate(data, new_col = old_col*2) output_2 &lt;- filter(output_1, other_col &gt; 5) output &lt;- select(output_2, new_col) This is difficult to understand for multiple reasons. The reader may be tricked into thinking the named output_1 and output_2 objects are important for some reason, while they are just temporary intermediate computations. Further, the reader has to look through and find where output_1 and output_2 are used in each subsequent line. Another option for doing this would be to compose the functions: output &lt;- select(filter(mutate(data, new_col = old_col*2), other_col &gt; 5), new_col) Code like this can also be difficult to understand. Functions compose (reading from left to right) in the opposite order in which they are computed by R (above, mutate happens first, then filter, then select). It is also just a really long line of code to read in one go. The pipe operator %&gt;% solves this problem, resulting in cleaner and easier-to-follow code. The below accomplishes the same thing as the previous two code blocks: output &lt;- data %&gt;% mutate(new_col = old_col*2) %&gt;% filter(other_col &gt; 5) %&gt;% select(new_col) You can think of the pipe as a physical pipe. It takes the output from the function on the left-hand side of the pipe, and passes it as the first argument to the function on the right-hand side of the pipe. Note here that we have again split the code across multiple lines for readability; R is fine with this, since it knows that a line ending in a pipe %&gt;% is continued on the next line. Next, let’s learn about the details of using the pipe, and look at some examples of how to use it in data analysis. 3.5.1 Using %&gt;% to combine filter and select Recall the US state-level property, income, population, and voting data that we explored in chapter 1: us_data &lt;- read_csv(&quot;data/state_property_vote.csv&quot;) us_data ## # A tibble: 52 x 6 ## state med_income med_prop_val population mean_commute_minutes party ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 AK 64222 197300 733375 10.5 Republican ## 2 AL 36924 94800 4830620 25.3 Republican ## 3 AR 35833 83300 2958208 22.4 Republican ## 4 AZ 44748 128700 6641928 20.6 Republican ## 5 CA 53075 252100 38421464 23.4 Democrat ## 6 CO 48098 198900 5278906 19.5 Democrat ## 7 CT 69228 246450 3593222 24.3 Democrat ## 8 DC 70848 475800 647484 28.3 Democrat ## 9 DE 54976 228500 926454 24.5 Democrat ## 10 FL 43355 125600 19645772 24.8 Republican ## # … with 42 more rows Suppose we want to create a subset of the data with only the values for median income and median property value for the state of California (“CA”). To do this, we can use the functions filter and select. First we use filter to create a data frame called ca_prop_data that contains only values for the state of California. We then use select on this data frame to keep only the median income and median property value variables: ca_prop_data &lt;- filter(us_data, state == &quot;CA&quot;) ca_inc_prop &lt;- select(ca_prop_data, med_income, med_prop_val) ca_inc_prop ## # A tibble: 1 x 2 ## med_income med_prop_val ## &lt;dbl&gt; &lt;dbl&gt; ## 1 53075 252100 Although this is valid code, there is a more readable approach we could take by using the pipe, %&gt;%. With the pipe, we do not need to create an intermediate object to store the output from filter. Instead we can directly send the output of filter to the input of select: ca_inc_prop &lt;- filter(us_data, state == &quot;CA&quot;) %&gt;% select(med_income, med_prop_val) ca_inc_prop ## # A tibble: 1 x 2 ## med_income med_prop_val ## &lt;dbl&gt; &lt;dbl&gt; ## 1 53075 252100 But wait - why does our select function call look different in these two examples? When you use the pipe, the output of the function on the left is automatically provided as the first argument for the function on the right, and thus you do not specify that argument in that function call. In the code above, the first argument of select is the data frame we are select-ing from, which is provided by the output of filter. As you can see, both of these approaches give us the same output but the second approach is more clear and readable. 3.5.2 Using %&gt;% with more than two functions The %&gt;% can be used with any function in R. Additionally, we can pipe together more than two functions. For example, we can pipe together three functions to order the states by commute time for states whose population is less than 1 million people: small_state_commutes &lt;- filter(us_data, population &lt; 1000000) %&gt;% select(state, mean_commute_minutes) %&gt;% arrange(mean_commute_minutes) small_state_commutes ## # A tibble: 7 x 2 ## state mean_commute_minutes ## &lt;chr&gt; &lt;dbl&gt; ## 1 AK 10.5 ## 2 SD 15.1 ## 3 ND 16.3 ## 4 WY 18.7 ## 5 VT 22.3 ## 6 DE 24.5 ## 7 DC 28.3 Note:: arrange is a function that takes the name of a data frame and one or more column(s), and returns a data frame where the rows are ordered by those columns in ascending order. Here we used only one column for sorting (mean_commute_minutes), but more than one can also be used. To do this, list additional columns separated by commas. The order they are listed in indicates the order in which they will be used for sorting. This is much like how an English dictionary sorts words: first by the first letter, then by the second letter, and so on. Another Note: You might also have noticed that we split the function calls across lines after the pipe, similar as to when we did this earlier in the chapter for long function calls. Again this is allowed and recommeded, especially when the piped function calls would create a long line of code. Doing this makes your code more readable. When you do this it is important to end each line with the pipe operator %&gt;% to tell R that your code is continuing onto the next line. 3.6 Iterating over data with group_by + summarize 3.6.1 Calculating summary statistics: As a part of many data analyses, we need to calculate a summary value for the data (a summary statistic). A useful dplyr function for doing this is summarize. Examples of summary statistics we might want to calculate are the number of observations, the average/mean value for a column, the minimum value for a column, etc. Below we show how to use the summarize function to calculate the minimum, maximum and mean commute time for all US states: us_commute_time_summary &lt;- summarize(us_data, min_mean_commute = min(mean_commute_minutes), max_mean_commute = max(mean_commute_minutes), mean_mean_commute = mean(mean_commute_minutes)) us_commute_time_summary ## # A tibble: 1 x 3 ## min_mean_commute max_mean_commute mean_mean_commute ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 10.5 29.0 22.2 3.6.2 Calculating group summary statistics: A common pairing with summarize is group_by. Pairing these functions together can let you summarize values for subgroups within a data set. For example, here we can use group_by to group the states based on which party they voted for in the US election, and then calculate the minimum, maximum and mean commute time for each of the groups. The group_by function takes at least two arguments. The first is the data frame that will be grouped, and the second and onwards are columns to use in the grouping. Here we use only one column for grouping (party), but more than one can also be used. To do this, list additional columns separated by commas. us_commute_time_summary_by_party &lt;- group_by(us_data, party) %&gt;% summarize(min_mean_commute = min(mean_commute_minutes), max_mean_commute = max(mean_commute_minutes), mean_mean_commute = mean(mean_commute_minutes)) us_commute_time_summary_by_party ## # A tibble: 3 x 4 ## party min_mean_commute max_mean_commute mean_mean_commute ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Democrat 18.5 28.8 23.2 ## 2 Not Applicable 29.0 29.0 29.0 ## 3 Republican 10.5 27.1 21.4 3.7 Additional reading on the dplyr functions We haven’t explicitly said this yet, but the tidyverse is actually a meta R package: it installs a collection of R packages that all follow the tidy data philosophy we discussed above. One of the tidyverse packages is dplyr - a data wrangling workhorse. You have already met 6 of the dplyr function (select, filter, mutate, arrange, summarize, and group_by). To learn more about those six and meet a few more useful functions, read the post at this link. 3.8 Using purrr’s map* functions to iterate Where should you turn when you discover the next step in your data wrangling/cleaning process requires you to apply a function to each column in a data frame? For example, if you wanted to know the maximum value of each column in a data frame? Well you could use summarize as discussed above, but this becomes inconvenient when you have many columns, as summarize requires you to type out a column name and a data tranformation for each summary statistic that you want to calculate. In cases like this, where you want to apply the same data transformation to all columns, it is more efficient to use purrr’s map function to apply it to each column. For example, let’s find the maximum value of each column of the mtcars data frame (a built-in data set that comes with R) by using map with the max function. First, let’s peak at the data to familiarize ourselves with it: head(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 Next, we use map to apply the max function to each column. map takes two arguments, an object (a vector, data frame or list) that you want to apply the function to, and the function that you would like to apply. Here our arguments will be mtcars and max: max_of_columns &lt;- map(mtcars, max) max_of_columns ## $mpg ## [1] 33.9 ## ## $cyl ## [1] 8 ## ## $disp ## [1] 472 ## ## $hp ## [1] 335 ## ## $drat ## [1] 4.93 ## ## $wt ## [1] 5.424 ## ## $qsec ## [1] 22.9 ## ## $vs ## [1] 1 ## ## $am ## [1] 1 ## ## $gear ## [1] 5 ## ## $carb ## [1] 8 Note: purrr is part of the tidyverse, and so like the dplyr and ggplot functions, once we call library(tidyverse) we do not need to separately load the purrr package. Our output looks a bit weird…we passed in a data frame, but our output doesn’t look like a data frame. As it so happens, it is not a data frame, but rather a plain vanilla list: typeof(max_of_columns) ## [1] &quot;list&quot; So what do we do? Should we convert this to a data frame? We could, but a simpler alternative is to just use a different map_* function from the purrr package. There are quite a few to choose from, they all work similarly and their name refects the type of output you want from the mapping operation: map function Output map() list map_lgl() logical vector map_int() integer vector map_dbl() double vector map_chr() character vector map_df() data frame Let’s get the column maximum’s again, but this time use the map_df function to return the output as a data frame: max_of_columns &lt;- map_df(mtcars, max) max_of_columns ## # A tibble: 1 x 11 ## mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 33.9 8 472 335 4.93 5.42 22.9 1 1 5 8 Which map_* function you choose depends on what you want to do with the output; you don’t always have to pick map_df! What if you need to add other arguments to the functions you want to map? For example, what if there were NA values in our columns that we wanted to know the maximum of? Well then we also need to add the argument na.rm = TRUE to the max function so that we get a more useful value than NA returned (remember that is what happens with many of the built-in R statistical functions when NA’s are present…). What we need to do in that case is do what is called “creating an anonymous function” within the map_df function. We do that in the place where we previously specified our max function. Here we will put the two calls to map_df right after each other so you can see the difference: # no additional arguments to the max function map_df(mtcars, max) versus # adding the na.rm = TRUE argument to the max function map_df(mtcars, function(df) max(df, na.rm = TRUE)) You can see that’s quite a bit of extra typing… So the creators of purrr have made a shortcut for this because it is so commonly done. In the shortcut we replace function(VARIABLE) with a ~ and replace the VARIABLE in the function call with a ., see the example below: # adding the na.rm = TRUE argument to the max function using the shortcut map_df(mtcars, ~ max(., na.rm = TRUE)) 3.8.1 A bit more about the map_* functions The map_* functions are generally quite useful for solving problems involving iteration/repetition. Additionally, their use is not limited to columns of a data frame; map_* functions can be used to apply functions to elements of a vector or list, and even to lists of data frames, or nested data frames. 3.9 Additional readings/resources Grolemund &amp; Wickham’s R for Data Science has a number of useful sections that provide additional information: Data transformation Tidy data The map_* functions "],
["viz.html", "Chapter 4 Effective data visualization 4.1 Overview 4.2 Chapter learning objectives 4.3 Choosing the visualization 4.4 Refining the visualization 4.5 Creating visualizations with ggplot2 4.6 Explaining the visualization 4.7 Saving the visualization", " Chapter 4 Effective data visualization 4.1 Overview This chapter will introduce concepts and tools relating to data visualization beyond what we have seen and practiced so far. We will focus on guiding principles for effective data visualization and explaining visualizations independent of any particular tool or programming language. In the process, we will cover some specifics of creating visualizations (scatter plots, bar charts, line graphs, and histograms) for data using R. There are external references that contain a wealth of additional information on the topic of data visualization: Professor Claus Wilke’s Fundamentals of Data Visualization has more details on general principles of effective visualizations Grolemund &amp; Wickham’s R for Data Science chapter on creating visualizations using ggplot2 has a deeper introduction into the syntax and grammar of plotting with ggplot2 specifically the ggplot2 reference has a useful list of useful ggplot2 functions 4.2 Chapter learning objectives Describe when to use the following kinds of visualizations: scatter plots line plots bar plots histogram plots Given a data set and a question, select from the above plot types to create a visualization that best answers the question Given a visualization and a question, evaluate the effectiveness of the visualization and suggest improvements to better answer the question Identify rules of thumb for creating effective visualizations Define the three key aspects of ggplot objects: aesthetic mappings geometric objects scales Use the ggplot2 library in R to create and refine the above visualizations using: geometric objects: geom_point, geom_line, geom_histogram, geom_bar, geom_vline, geom_hline scales: scale_x_continuous, scale_y_continuous aesthetic mappings: x, y, fill, colour, shape labelling: xlab, ylab, labs font control and legend positioning: theme flipping axes: coord_flip subplots: facet_grid Describe the difference in raster and vector output formats Use ggsave to save visualizations in .png and .svg format 4.3 Choosing the visualization Ask a question, and answer it The purpose of a visualization is to answer a question about a data set of interest. So naturally, the first thing to do before creating a visualization is to formulate the question about the data that you are trying to answer. A good visualization will answer your question in a clear way without distraction; a great visualization will suggest even what the question was itself without additional explanation. Imagine your visualization as part of a poster presentation for your project; even if you aren’t standing at the poster explaining things, an effective visualization will be able to convey your message to the audience. Recall the different types of data analysis question from the very first chapter of this book. With the visualizations we will cover in this chapter, we will be able to answer only descriptive and exploratory questions. Be careful not to try to answer any predictive, inferential, causal or mechanistic questions, as we have not learned the tools necessary to do that properly just yet. As with most coding tasks, it is totally fine (and quite common) to make mistakes and iterate a few times before you find the right visualization for your data and question. There are many different kinds of plotting graphic available to use. For the kinds we will introduce in this course, the general rules of thumb are: line plots visualize trends with respect to an independent, ordered quantity (e.g. time) histograms visualize the distribution of one quantitative variable (i.e., all its possible values and how often they occur) scatter plots visualize the distribution / relationship of two quantitative variables bar plots visualize comparisons of amounts All types of visualization have their (mis)uses, but there are three kinds that are usually hard to understand or are easily replaced with an oft-better alternative. In particular you should avoid pie charts; it is usually better to use bars, as it is easier to compare bar heights than pie slice sizes. You should also not use 3-D visualizations, as they are typically hard to understand when converted to a static 2-D image format. Finally, do not use tables to make numerical comparisons; humans are much better at quickly processing visual information than text and math. Bar plots are again typically a better alternative. 4.4 Refining the visualization Convey the message, minimize noise Just being able to make a visualization in R with ggplot2 (or any other tool for that matter) doesn’t mean that it is effective at communicating your message to others. Once you have selected a broad type of visualization to use, you will have to refine it to suit your particular need. Some rules of thumb for doing this are listed below. They generally fall into two classes: you want to make your visualization convey your message, and you want to reduce visual noise as much as possible. Humans have limited cognitive ability to process information; both of these types of refinement aim to reduce the mental load on your audience when viewing your visualization, making it easier for them to quickly understand and remember your message. Convey the message Make sure the visualization answers the question you have asked in the simplest and most plain way possible. Use legends and labels so that your visualization is understandable without reading the surrounding text. Ensure the text, symbols, lines, etc. on your visualization are big enough to be easily read. Make sure the data are clearly visible; don’t hide the shape/distribution of the data behind other objects (e.g. a bar). Make sure to use colourschemes that are understandable by those with colourblindness (a surprisingly large fraction of the overall population). For example, colorbrewer.org and the RColorBrewer R library provide the ability to pick such colourschemes, and you can check your visualizations after you have created them by uploading to online tools such as the colour blindness simulator. Redundancy can be helpful; sometimes conveying the same message in multiple ways reinforces it for the audience. Minimize noise Use colours sparingly. Too many different colours can be distracting, create false patterns, and detract from the message. Be wary of overplotting. If your plot has too many dots or lines and it starts to look like a mess, then you need to do something different. Only make the plot area (where the dots, lines, bars are) as big as needed. Simple plots can be made small. Don’t adjust the axes to zoom in on small differences. If the difference is small, show that it’s small! 4.5 Creating visualizations with ggplot2 Build the visualization iteratively This section will cover examples of how to choose and refine a visualization given a data set and a question that you want to answer, and then how to create the visualization in R using ggplot2. To use the ggplot2 library, we need to load the tidyverse metapackage. library(tidyverse) 4.5.1 The Mauna Loa CO2 data set This data set contains the atmospheric concentration of carbon dioxide (CO2, in parts per million) at the Mauna Loa research station in Hawaii from the years 1959-1997. Question: Does the concentration of atmospheric CO2 change over time, and are there any interesting patterns to note? # mauna loa carbon dioxide data co2_df &lt;- read_csv(&quot;data/maunaloa.csv&quot;) head(co2_df) ## # A tibble: 6 x 2 ## concentration date ## &lt;dbl&gt; &lt;dbl&gt; ## 1 315. 1959 ## 2 316. 1959. ## 3 316. 1959. ## 4 318. 1959. ## 5 318. 1959. ## 6 318 1959. Since we are investigating a relationship between two variables (CO2 concentration and date), a scatter plot is a good place to start. Scatter plots show the data as individual points with x (horizonal axis) and y (vertical axis) coordinates. Here, we will use the date as the x coordinate and CO2 concentration as the y coordinate. When using the ggplot2 library, we create the plot object with the ggplot function; there are a few basic aspects of a plot that we need to specify: the data: the name of the dataframe object that we would like to visualize here, we specify the co2_df dataframe the aesthetic mapping: tells ggplot how the columns in the dataframe map to properties of the visualization to create an aesthetic mapping, we use the aes function here, we set the plot x axis to the date variable, and the plot y axis to the concentration variable the geometric object: specifies how the mapped data should be displayed to create a geometric object, we use a geom_* function (see the ggplot reference for a list of geometric objects) here, we use the geom_point function to visualize our data as a scatterplot There are many other possible arguments we could pass to the aesthetic mapping and geometric object to change how the plot looks. For the purposes of quickly testing things out to see what they look like, though, we can just go with the default settings: co2_scatter &lt;- ggplot(co2_df, aes(x = date, y = concentration)) + geom_point() co2_scatter Certainly the visualization shows a clear upward trend in the atmospheric concentration of CO2 over time. This plot answers the first part of our question in the affirmative, but that appears to be the only conclusion one can make from the scatter visualization. However, since time is an ordered quantity, we can try using a line plot instead using the geom_line function. Line plots require that the data are ordered by their x coordinate, and connect the sequence of x and y coordinates with line segments. Let’s again try this with just the default arguments: co2_line &lt;- ggplot(co2_df, aes(x = date, y = concentration)) + geom_line() co2_line Aha! There is another interesting phenomenon in the data: in addition to increasing over time, the concentration seems to oscillate as well. Given the visualization as it is now, it is still hard to tell how fast the oscillation is, but nevertheless, the line seems to be a better choice for answering the question than the scatter plot was. The comparison between these two visualizations illustrates a common issue with scatter plots: often the points are shown too close together or even on top of one another, muddling information that would otherwise be clear (overplotting). Now that we have settled on the rough details of the visualization, it is time to refine things. This plot is fairly straightforward, and there is not much visual noise to remove. But there are a few things we must do to improve clarity, such as adding informative axis labels and making the font a more readable size. In order to add axis labels we use the xlab and ylab functions. To change the font size we use the theme function with the text argument: co2_line &lt;- ggplot(co2_df, aes(x = date, y = concentration)) + geom_line() + xlab(&#39;Year&#39;) + ylab(&#39;Atmospheric CO2 (ppm)&#39;) + theme(text = element_text(size = 18)) co2_line Finally, let’s see if we can better understand the oscillation by changing the visualization a little bit. Note that it is totally fine to use a small number of visualizations to answer different aspects of the question you are trying to answer. We will accomplish this by using scales, another important feature of ggplot2 that allow us to easily transform the different variables and set limits. We scale the horizontal axis by using the scale_x_continuous function, and the vertical axis with the scale_y_continuous function. We can transform the axis by passing the trans argument, and set limits by passing the limits argument. In particular, here we will use the scale_x_continuous function with the limits argument to zoom in on just five years of data (say, 1990-1995): co2_line &lt;- ggplot(co2_df, aes(x = date, y = concentration)) + geom_line() + xlab(&#39;Year&#39;) + ylab(&#39;Atmospheric CO2 (ppm)&#39;) + scale_x_continuous(limits = c(1990, 1995)) + theme(text = element_text(size = 18)) co2_line Interesting! It seems that each year, the atmospheric CO2 increases until it reaches its peak somewhere around April, decreases until around late September, and finally increases again until the end of the year. In Hawaii, there are two seasons: summer from May through October, and winter from November through April. Therefore, the oscillating pattern in CO2 matches up fairly closely with the two seasons. 4.5.2 The island landmass data set This data set contains a list of Earth’s land masses as well as their area (in thousands of square miles). Question: Are the continents (North / South America, Africa, Europe, Asia, Australia, Antarctica) Earth’s 7 largest landmasses? If so, what are the next few largest landmasses after those? # islands data islands_df &lt;- read_csv(&quot;data/islands.csv&quot;) head(islands_df) ## # A tibble: 6 x 2 ## landmass size ## &lt;chr&gt; &lt;dbl&gt; ## 1 Africa 11506 ## 2 Antarctica 5500 ## 3 Asia 16988 ## 4 Australia 2968 ## 5 Axel Heiberg 16 ## 6 Baffin 184 Here, we have a list of Earth’s landmasses, and are trying to compare their sizes. The right type of visualization to answer this question is a bar plot, specified by the geom_bar function in ggplot2. However, by default, geom_bar sets the heights of bars to the number of times a value appears in a dataframe (its count); here we want to plot exactly the values in the dataframe, i.e., the landmass sizes. So we have to pass the stat = &quot;identity&quot; argument to geom_bar: islands_bar &lt;- ggplot(islands_df, aes(x = landmass, y = size)) + geom_bar(stat = &quot;identity&quot;) islands_bar Alright, not bad! This is definitely the right kind of visualization, as we can clearly see and compare sizes of landmasses. The major issues are that the sizes of the smaller landmasses are hard to distinguish, and that the names of the landmasses are obscuring each other as they have been squished into too little space. But remember that the question we asked was only about the largest landmasses; let’s make the plot a little bit clearer by keeping only the largest 12 landmasses. We do this using the top_n function. Then to help us make sure the labels have enough space, we’ll use horizontal bars instead of vertical ones. We do this using the coord_flip function, which swaps the x and y coordinate axes: islands_top12 &lt;- top_n(islands_df, 12, size) islands_bar &lt;- ggplot(islands_top12, aes(x = landmass, y = size)) + geom_bar(stat = &quot;identity&quot;) + coord_flip() islands_bar This is definitely clearer now, and allows us to answer our question (“are the top 7 largest landmasses continents?”) in the affirmative. But the question could be made clearer from the plot by organizing the bars not by alphabetical order but by size, and to colour them based on whether or not they are a continent. In order to do this, we use mutate to add a column to the data regarding whether or not the landmass is a continent: islands_top12 &lt;- top_n(islands_df, 12, size) continents &lt;- c(&#39;Africa&#39;, &#39;Antarctica&#39;, &#39;Asia&#39;, &#39;Australia&#39;, &#39;Europe&#39;, &#39;North America&#39;, &#39;South America&#39;) islands_ct &lt;- mutate(islands_top12, is_continent = ifelse(landmass %in% continents, &#39;Continent&#39;, &#39;Other&#39;)) head(islands_ct) ## # A tibble: 6 x 3 ## landmass size is_continent ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Africa 11506 Continent ## 2 Antarctica 5500 Continent ## 3 Asia 16988 Continent ## 4 Australia 2968 Continent ## 5 Baffin 184 Other ## 6 Borneo 280 Other In order to colour the bars, we add the fill argument to the aesthetic mapping. Then we use the reorder function in the aesthetic mapping to organize the landmasses by their size variable. Finally, we use the labs and theme functions to add labels, change the font size, and position the legend: islands_bar &lt;- ggplot(islands_ct, aes(x = reorder(landmass, size), y = size, fill = is_continent)) + geom_bar(stat=&quot;identity&quot;) + labs(x = &#39;Landmass&#39;, y = &#39;Size (1000 square mi)&#39;, fill = &#39;Type&#39;) + coord_flip() + theme(text = element_text(size = 18), legend.position = c(0.75, 0.45)) islands_bar This is now a very effective visualization for answering our original questions. Landmasses are organized by their size, and continents are coloured differently than other landmasses, making it quite clear that continents are the largest 7 landmasses. 4.5.3 The Old Faithful eruption / waiting time data set This data set contains measurements of the waiting time between eruptions and the subsequent eruption duration (in minutes). Question: Is there a relationship between the waiting time before an eruption to the duration of the eruption? # old faithful eruption time / wait time data head(faithful) ## eruptions waiting ## 1 3.600 79 ## 2 1.800 54 ## 3 3.333 74 ## 4 2.283 62 ## 5 4.533 85 ## 6 2.883 55 Here again we are investigating the relationship between two quantitative variables (waiting time and eruption time). But if you look at the output of the head function, you’ll notice that neither of the columns are ordered. So in this case, let’s start again with a scatter plot: faithful_scatter &lt;- ggplot(faithful, aes(x = waiting, y = eruptions)) + geom_point() faithful_scatter We can see that the data tend to fall into two groups: one with a short waiting and eruption times, and one with long waiting and eruption times. Note that in this case, there is no overplotting: the points are generally nicely visually separated, and the pattern they form is clear. In order to refine the visualization, we need only to add axis labels and make the font more readable: faithful_scatter &lt;- ggplot(faithful, aes(x = waiting, y = eruptions)) + geom_point() + labs(x = &#39;Waiting Time (mins)&#39;, y = &#39;Eruption Duration (mins)&#39;) + theme(text = element_text(size = 18)) faithful_scatter 4.5.4 The Michelson speed of light data set This data set contains measurements of the speed of light (in kilometres per second with 299,000 subtracted) from the year 1879 for 5 experiments, each with 20 consecutive runs. Question: Given what we know now about the speed of light (299,792.458 kilometres per second), how accurate were each of the experiments? # michelson morley experimental data head(morley) ## Expt Run Speed ## 001 1 1 850 ## 002 1 2 740 ## 003 1 3 900 ## 004 1 4 1070 ## 005 1 5 930 ## 006 1 6 850 In this experimental data, Michelson was trying to measure just a single quantitative number (the speed of light). The data set contains many measurements of this single quantity. To tell how accurate the experiments were, we need to visualize the distribution of the measurements (i.e., all their possible values and how often each occurs). We can do this using a histogram. A histogram helps us visualize how a particular variable is distributed in a data set by separating the data into bins, and then using vertical bars to show how many data points fell in each bin. To create a histogram in ggplot2 we will use the geom_histogram geometric object, setting the x axis to the Speed measurement variable; and as we did before, let’s use the default arguments just to see how things look: morley_hist &lt;- ggplot(morley, aes(x = Speed)) + geom_histogram() morley_hist This is a great start. However, we cannot tell how accurate the measurements are using this visualization unless we can see what the true value is. In order to visualize the true speed of light, we will add a vertical line with the geom_vline function, setting the xintercept argument to the true value. There is a similar function, geom_hline, that is used for plotting horizontal lines. Note that vertical lines are used to denote quantities on the horizontal axis, while horizontal lines are used to denote quantities on the vertical axis. morley_hist &lt;- ggplot(morley, aes(x = Speed)) + geom_histogram() + geom_vline(xintercept = 792.458, linetype = &quot;dashed&quot;, size = 1.0) morley_hist We also still cannot tell which experiments (denoted in the Expt column) led to which measurements; perhaps some experiments were more accurate than others. To fully answer our question, we need to separate the measurements from each other visually. We can try to do this using a coloured histogram, where counts from different experiments are stacked on top of each other in different colours. We create a histogram coloured by the Expt variable by adding it to the fill aesthetic mapping. We make sure the different colours can be seen (despite them all sitting on top of each other) by setting the alpha argument in geom_histogram to 0.5 to make the bars slightly translucent: morley_hist &lt;- ggplot(morley, aes(x = Speed, fill = factor(Expt))) + geom_histogram(position = &quot;identity&quot;, alpha = 0.5) + geom_vline(xintercept = 792.458, linetype = &quot;dashed&quot;, size = 1.0) morley_hist Unfortunately, the attempt to separate out the experiment number visually has created a bit of a mess. All of the colours are blending together, and although it is possible to derive some insight from this (e.g., experiments 1 and 3 had some of the most incorrect measurements), it isn’t the clearest way to convey our message and answer the question. Let’s try a different strategy of creating multiple separate histograms on top of one another. In order to create a plot in ggplot2 that has multiple subplots arranged in a grid, we use the facet_grid function. The argument to facet_grid specifies the variable(s) used to split the plot into subplots. It has the syntax vertical_variable ~ horizontal_variable, where veritcal_variable is used to split the plot vertically, horizontal_variable is used to split horizontally, and . is used if there should be no split along that axis. In our case we only want to split vertically along the Expt variable, so we use Expt ~ . as the argument to facet_grid. morley_hist &lt;- ggplot(morley, aes(x = Speed, fill = factor(Expt))) + geom_histogram(position = &quot;identity&quot;) + facet_grid(Expt ~ .) + geom_vline(xintercept = 792.458, linetype = &quot;dashed&quot;, size = 1.0) morley_hist The visualization now makes it quite clear how accurate the different experiments were with respect to one another. There are two finishing touches to make this visualization even clearer. First and foremost, we need to add informative axis labels using the labs function, and increase the font size to make it readable using the theme function. Second, and perhaps more subtly, even though it is easy to compare the experiments on this plot to one another, it is hard to get a sense for just how accurate all the experiments were overall. For example, how accurate is the value 800 on the plot, relative to the true speed of light? To answer this question we’ll use the mutate function to transform our data into a relative measure of accuracy rather than absolute measurements: morley_rel &lt;- mutate(morley, relative_accuracy = 100*( (299000 + Speed) - 299792.458 ) / (299792.458)) morley_hist &lt;- ggplot(morley_rel, aes(x = relative_accuracy, fill = factor(Expt))) + geom_histogram(position = &quot;identity&quot;) + facet_grid(Expt ~ .) + geom_vline(xintercept = 0, linetype = &quot;dashed&quot;, size = 1.0) + labs(x = &#39;Relative Accuracy (%)&#39;, y = &#39;# Measurements&#39;, fill = &#39;Experiment ID&#39;) + theme(text = element_text(size = 18)) morley_hist Wow, impressive! These measurements of the speed of light from 1879 had errors around 0.05% of the true speed. This shows you that even though experiments 2 and 5 were perhaps the most accurate, all of the experiments did quite an admirable job given the technology available at the time period. 4.6 Explaining the visualization Tell a story Typically, your visualization will not be shown completely on its own, but rather it will be part of a larger presentation. Further, visualizations can provide supporting information for any part of a presentation, from opening to conclusion. For example, you could use an exploratory visualization in the opening of the presentation to motivate your choice of a more detailed data analysis / model, a visualization of the results of your analysis to show what your analysis has uncovered, or even one at the end of a presentation to help suggest directions for future work. Regardless of where it appears, a good way to discuss your visualization is as a story: Establish the setting and scope, and motivate why you did what you did. Pose the question that your visualization answers. Justify why the question is important to answer. Answer the question using your visualization. Make sure you describe all aspects of the visualization (including describing the axes). But you can emphasize different aspects based on what is important to answering your question: trends (lines): Does a line describe the trend well? If so, the trend is linear, and if not, the trend is nonlinear. Is the trend increasing, decreasing, or neither? Is there a periodic oscillation (wiggle) in the trend? Is the trend noisy (does the line “jump around” a lot) or smooth? distributions (scatters, histograms): How spread out are the data? Where are they centered, roughly? Are there any obvious “clusters” or “subgroups”, which would be visible as multiple bumps in the histogram? distributions of two variables (scatters): is there a clear / strong relationship between the variables (points fall in a distinct pattern), a weak one (points fall in a pattern but there is some noise), or no discernible relationship (the data are too noisy to make any conclusion)? amounts (bars): How large are the bars relative to one another? Are there patterns in different groups of bars? Summarize your findings, and use them to motivate whatever you will discuss next. Below are two examples of how might one take these four steps in describing the example visualizations that appeared earlier in this chapter. Each of the steps is denoted by its numeral in parentheses, e.g. (3). Mauna Loa Atmospheric CO2 Measurements: (1) Many current forms of energy generation and conversion—from automotive engines to natural gas power plants—rely on burning fossil fuels and produce greenhouse gases, typically primarily carbon dioxide (CO2), as a byproduct. Too much of these gases in the Earth’s atmosphere will cause it to trap more heat from the sun, leading to global warming. (2) In order to assess how quickly the atmospheric concentration of CO2 is increasing over time, we (3) used a data set from the Mauna Loa observatory from Hawaii, consisting of CO2 measurements from 1959 to the present. We plotted the measured concentration of CO2 (on the vertical axis) over time (on the horizontal axis). From this plot you can see a clear, increasing, and generally linear trend over time. There is also a periodic oscillation that occurs once per year and aligns with Hawaii’s seasons, with an amplitude that is small relative to the growth in the overall trend. This shows that atmospheric CO2 is clearly increasing over time, and (4) it is perhaps worth investigating more into the causes. Michelson Light Speed Experiments: (1) Our modern understanding of the physics of light has advanced significantly from the late 1800s when experiments of Michelson and Morley first demonstrated that it had a finite speed. We now know based on modern experiments that it moves at roughly 299792.458 kilometres per second. (2) But how accurately were we first able to measure this fundamental physical constant, and did certain experiments produce more accurate results than others? (3) To better understand this we plotted data from 5 experiments by Michelson in 1879, each with 20 trials, as histograms stacked on top of one another. The horizontal axis shows the accuracy of the measurements relative to the true speed of light as we know it today, expressed as a percentage. From this visualization you can see that most results had relative errors of at most 0.05%. You can also see that experiments 1 and 3 had measurements that were the farthest from the true value, and experiment 5 tended to provide the most consistently accurate result. (4) It would be worth further investigation into the differences between these experiments to see why they produced different results. 4.7 Saving the visualization Choose the right output format for your needs Just as there are many ways to store data sets, there are many ways to store visualizations and images. Which one you choose can depend on a number of factors, such as file size/type limitations (e.g., if you are submitting your visualization as part of a conference paper or to a poster printing shop) and where it will be displayed (e.g., online, in a paper, on a poster, on a billboard, in talk slides). Generally speaking, images come in two flavours: bitmap (or raster) formats and vector (or scalable graphics) formats. Bitmap / Raster images are represented as a 2-D grid of square pixels, each with their own colour. Raster images are often compressed before storing so they take up less space. A compressed format is lossy if the image cannot be perfectly recreated when loading and displaying, with the hope that the change is not noticeable. Lossless formats, on the other hand, allow a perfect display of the original image. Common file types: JPEG (.jpg, .jpeg): lossy, usually used for photographs PNG (.png): lossless, usually used for plots / line drawings BMP (.bmp): lossless, raw image data, no compression (rarely used) TIFF (.tif, .tiff): typically lossless, no compression, used mostly in graphic arts, publishing Open-source software: GIMP Vector / Scalable Graphics images are represented as a collection of mathematical objects (lines, surfaces, shapes, curves). When the computer displays the image, it redraws all of the elements using their mathematical formulas. Common file types: SVG (.svg): general-purpose use EPS (.eps), general-purpose use (rarely used) Open-source software: Inkscape Raster and vector images have opposing advantages and disadvantages. A raster image of a fixed width / height takes the same amount of space and time to load regardless of what the image shows (caveat: the compression algorithms may shrink the image more or run faster for certain images). A vector image takes space and time to load corresponding to how complex the image is, since the computer has to draw all the elements each time it is displayed. For example, if you have a scatter plot with 1 million points stored as an SVG file, it may take your computer some time to open the image. On the other hand, you can zoom into / scale up vector graphics as much as you like without the image looking bad, while raster images eventually start to look “pixellated.” PDF files: The portable document format PDF (.pdf) is commonly used to store both raster and vector graphics formats. If you try to open a PDF and it’s taking a long time to load, it may be because there is a complicated vector graphics image that your computer is rendering. Let’s investigate how different image file formats behave with a scatter plot of the Old Faithful data set, which happens to be available in base R under the name faithful: library(svglite) #we need this to save SVG files faithful_plot &lt;- ggplot(data = faithful, aes(x = waiting, y = eruptions))+ geom_point() faithful_plot ggsave(&#39;faithful_plot.png&#39;, faithful_plot) ggsave(&#39;faithful_plot.jpg&#39;, faithful_plot) ggsave(&#39;faithful_plot.bmp&#39;, faithful_plot) ggsave(&#39;faithful_plot.tiff&#39;, faithful_plot) ggsave(&#39;faithful_plot.svg&#39;, faithful_plot) print(paste(&quot;PNG filesize: &quot;, file.info(&#39;faithful_plot.png&#39;)[&#39;size&#39;] / 1000000, &quot;MB&quot;)) ## [1] &quot;PNG filesize: 0.193195 MB&quot; print(paste(&quot;JPG filesize: &quot;, file.info(&#39;faithful_plot.jpg&#39;)[&#39;size&#39;] / 1000000, &quot;MB&quot;)) ## [1] &quot;JPG filesize: 0.203905 MB&quot; print(paste(&quot;BMP filesize: &quot;, file.info(&#39;faithful_plot.bmp&#39;)[&#39;size&#39;] / 1000000, &quot;MB&quot;)) ## [1] &quot;BMP filesize: 12.585658 MB&quot; print(paste(&quot;TIFF filesize: &quot;, file.info(&#39;faithful_plot.tiff&#39;)[&#39;size&#39;] / 1000000, &quot;MB&quot;)) ## [1] &quot;TIFF filesize: 12.588634 MB&quot; print(paste(&quot;SVG filesize: &quot;, file.info(&#39;faithful_plot.svg&#39;)[&#39;size&#39;] / 1000000, &quot;MB&quot;)) ## [1] &quot;SVG filesize: 0.046623 MB&quot; Wow, that’s quite a difference! Notice that for such a simple plot with few graphical elements (points), the vector graphics format (SVG) is over 100 times smaller than the uncompressed raster images (BMP, TIFF). Also note that the JPG format is twice as large as the PNG format, since the JPG compression algorithm is designed for natural images (not plots). Below, we also show what the images look like when we zoom in to a rectangle with only 3 data points. You can see why vector graphics formats are so useful: because they’re just based on mathematical formulas, vector graphics can be scaled up to arbitrary sizes. This makes them great for presentation media of all sizes, from papers to posters to billboards. Zoomed in faithful, raster (PNG, left) and vector (SVG, right) formats. "],
["GitHub.html", "Chapter 5 Version control with GitHub 5.1 Overview 5.2 Videos to learn about version control with GitHub and Git 5.3 Git command cheatsheet 5.4 Terminal cheatsheet", " Chapter 5 Version control with GitHub 5.1 Overview We will be using version control with GitHub and Git to share our code on group projects. Here is a list of videos you might want to watch to familiarize yourself further with these tools, as well as a cheatsheet of Git and terminal commands. 5.2 Videos to learn about version control with GitHub and Git 5.2.1 Creating a GitHub repository 5.2.2 Exploring a GitHub repository 5.2.3 Directly editing files on GitHub 5.2.4 Logging changes and pushing them to GitHub 5.3 Git command cheatsheet Because we are writing code on a server, we need to use Git in the terminal to get files from GitHub, and to send back changes to the files that we make on the server. Below is a cheat sheet of the commands you will need and what they are for: 5.3.1 Getting a repository from GitHub onto the server for the first time This is done only once for a repository when you want to copy it to a new computer. git clone https://github.com/USERNAME/GITHUB_REPOSITORY_NAME.git 5.3.2 Logging changes After editing and saving your files (e.g., a Jupyter notebook): git add FILENAME git commit -m &quot;some message about the changes you made&quot; 5.3.3 Sending your changes back to GitHub After logging your changes (as shown above): git push 5.3.4 Getting changes To get the changes your collaborator just sent to GitHub onto your server: git pull 5.4 Terminal cheatsheet We need to run the above Git commands from inside the repository/folder that we cloned from GitHub. To navigate there in the terminal, you will need to use the following commands: 5.4.1 See where you are: pwd 5.4.2 See what is inside the directory where you are: ls 5.4.3 Move to a different directory cd DIRECTORY_PATH "],
["classification.html", "Chapter 6 Classification I: Training &amp; predicting 6.1 Overview 6.2 Chapter learning objectives 6.3 The classification problem 6.4 Exploring a labelled data set 6.5 Classification with K-nearest neighbours 6.6 K-nearest neighbours in R 6.7 Data preprocessing", " Chapter 6 Classification I: Training &amp; predicting 6.1 Overview Up until this point, we have focused solely on descriptive and exploratory questions about data. This chapter and the next together serve as our first foray into answering predictive questions about data. In particular, we will focus on the problem of classification, i.e., using one or more quantitative variables to predict the value of a third, categorical variable. This chapter will cover the basics of classification, how to preprocess data to make it suitable for use in a classifier, and how to use our observed data to make predictions. The next will focus on how to evaluate how accurate the predictions from our classifier are, as well as how to improve our classifier (where possible) to maximize its accuracy. 6.2 Chapter learning objectives Recognize situations where a classifier would be appropriate for making predictions Describe what a training data set is and how it is used in classification Interpret the output of a classifier Compute, by hand, the straight-line (Euclidean) distance between points on a graph when there are two explanatory variables/predictors Explain the K-nearest neighbour classification algorithm Standardize variables in R, and explain why standardization is useful in predictive modelling Handle imbalanced data by oversampling in R, and explain why imbalanced data are problematic for classifiers Perform K-nearest neighbour classification in R using caret::train(method = &quot;knn&quot;, ...) 6.3 The classification problem In many situations, we want to make predictions based on the current situation as well as past experiences. For instance, a doctor may want to diagnose a patient as either diseased or healthy based on their symptoms and the doctor’s past experience with patients; an email provider might want to tag a given email as “spam” or “non-spam” depending on past email text data; or an online store may want to predict whether an order is fraudulent or not. These tasks are all examples of classification, i.e., predicting a categorical class (sometimes called a label) for an observation given its other quantitative variables (sometimes called features). Generally, a classifier assigns an observation (e.g. a new patient) to a class (e.g. diseased or healthy) on the basis of how similar it is to other observations for which we know the class (e.g. previous patients with known diseases and symptoms). These observations with known classes that we use as a basis for prediction are called a training set. We call them a “training set” because we use these observations to train, or teach, our classifier so that we can use it to make predictions on new data that we have not seen previously. There are many possible classification algorithms that we could use to predict a categorical class/label for an observation. In addition, there are many variations on the basic classification problem, e.g., binary classification where only two classes are involved (e.g. disease or healthy patient), or multiclass classification, which involves assigning an object to one of several classes (e.g., private, public, or not for-profit organization). Here we will focus on the simple, widely used K-nearest neighbours algorithm for the binary classification problem. Other examples you may encounter in future courses include decision trees, support vector machines (SVMs), logistic regression, and neural networks. 6.4 Exploring a labelled data set In this chapter and the next, we will study a data set of digitized breast cancer image features, created by Dr. William H. Wolberg, W. Nick Street, and Olvi L. Mangasarian at the University of Wisconsin, Madison. Each row in the data set represents an image of a tumour sample, including the diagnosis (benign or malignant) and several other measurements (e.g., nucleus texture, perimeter, area, etc.). Diagnosis for each image was conducted by physicians. As with all data analyses, we first need to formulate a precise question that we want to answer. Here, the question is predictive: can we use the tumour image measurements available to us to predict whether a future tumour image (with unknown diagnosis) shows a benign or malignant tumour? Answering this question is important because traditional, non-data-driven methods for tumour diagnosis are quite subjective and dependent upon how skilled and experienced the diagnosing physician is. Furthermore, benign tumours are not normally dangerous; the cells stay in the same place and the tumour stops growing before it gets very large. By contrast, in malignant tumours, the cells invade the surrounding tissue and spread into nearby organs where they can cause serious damage (learn more about cancer here). Thus, it is important to quickly and accurately diagnose the tumour type to guide patient treatment. Loading the data Our first step is to load, wrangle, and explore the data using visualizations in order to better understand the data we are working with. We start by loading the necessary libraries for our analysis. Below you’ll see (in addition to the usual tidyverse) a new library, forcats, that enables us to easily manipulate factors in R. Factors are a special categorical type of variable in R that are very helpful when doing data analysis with categorical variables. library(tidyverse) library(forcats) In this case, the file containing the breast cancer data set is a simple .csv file with headers. We’ll use the read_csv function with no additional arguments, and then the head function to inspect its contents: cancer &lt;- read_csv(&quot;data/clean-wdbc.data.csv&quot;) head(cancer) ## # A tibble: 6 x 12 ## ID Class Radius Texture Perimeter Area Smoothness Compactness ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 8.42e5 M 1.89 -1.36 2.30 2.00 1.31 2.61 ## 2 8.43e5 M 1.80 -0.369 1.53 1.89 -0.375 -0.430 ## 3 8.43e7 M 1.51 -0.0240 1.35 1.46 0.527 1.08 ## 4 8.43e7 M -0.281 0.134 -0.250 -0.550 3.39 3.89 ## 5 8.44e7 M 1.30 -1.47 1.34 1.22 0.220 -0.313 ## 6 8.44e5 M -0.165 -0.314 -0.115 -0.244 2.05 1.72 ## # … with 4 more variables: Concavity &lt;dbl&gt;, Concave_points &lt;dbl&gt;, ## # Symmetry &lt;dbl&gt;, Fractal_dimension &lt;dbl&gt; Variable descriptions Breast tumours can be diagnosed by performing a biopsy, a process where tissue is removed from the body to diagnose the presence of a disease. Traditionally these procedures were quite invasive; modern methods such as fine needle asipiration, used to collect the present data set, extract only a small amount of tissue and are less invasive. Based on a digital image of each breast tissue sample collected for this data set, 10 different variables were measured for each cell nucleus in the image (3-12 below), and then the mean of the three largest values for each variable across the nuclei was recorded. As part of the data preparation, these values have been scaled; we will discuss what this means and why we do it later in this chapter. Each image additionally was given a unique ID and a diagnosis for malignance by a physician. Therefore, the total set of variables per image in this data set are: ID number Class - diagnosis (M = malignant, B = benign) radius (mean of distances from center to points on the perimeter) texture (standard deviation of gray-scale values) perimeter area smoothness (local variation in radius lengths) compactness (\\(perimeter^2 / area - 1.0\\)) concavity (severity of concave portions of the contour) concave points (number of concave portions of the contour) symmetry fractal dimension (\\(&quot;coastline\\: approximation&quot; - 1\\)) A magnified image of a malignant breast fine needle aspiration image. White lines denote the boundary of the cell nuclei. Source: https://www.semanticscholar.org/paper/Breast-Cancer-Diagnosis-and-Prognosis-Via-Linear-P-Mangasarian-Street/3721bb14b16e866115c906336e9d70db096c05b9/figure/0 Below we use glimpse to preview the data frame. This function is similar to head, but can be easier to read when we have a lot of columns: glimpse(cancer) ## Observations: 569 ## Variables: 12 ## $ ID &lt;dbl&gt; 842302, 842517, 84300903, 84348301, 84358402, … ## $ Class &lt;chr&gt; &quot;M&quot;, &quot;M&quot;, &quot;M&quot;, &quot;M&quot;, &quot;M&quot;, &quot;M&quot;, &quot;M&quot;, &quot;M&quot;, &quot;M&quot;, &quot;… ## $ Radius &lt;dbl&gt; 1.8850310, 1.8043398, 1.5105411, -0.2812170, 1… ## $ Texture &lt;dbl&gt; -1.35809849, -0.36887865, -0.02395331, 0.13386… ## $ Perimeter &lt;dbl&gt; 2.30157548, 1.53377643, 1.34629062, -0.2497195… ## $ Area &lt;dbl&gt; 1.999478159, 1.888827020, 1.455004298, -0.5495… ## $ Smoothness &lt;dbl&gt; 1.306536657, -0.375281748, 0.526943750, 3.3912… ## $ Compactness &lt;dbl&gt; 2.61436466, -0.43006581, 1.08198014, 3.8899746… ## $ Concavity &lt;dbl&gt; 2.10767182, -0.14661996, 0.85422232, 1.9878391… ## $ Concave_points &lt;dbl&gt; 2.29405760, 1.08612862, 1.95328166, 2.17387323… ## $ Symmetry &lt;dbl&gt; 2.7482041, -0.2436753, 1.1512420, 6.0407261, -… ## $ Fractal_dimension &lt;dbl&gt; 1.93531174, 0.28094279, 0.20121416, 4.93067187… We can see from the summary of the data above that Class is of type character (denoted by &lt;chr&gt;). Since we are going to be working with Class as a categorical statistical variable, we will convert it to factor using the function as.factor. cancer &lt;- cancer %&gt;% mutate(Class = as.factor(Class)) Factors have what are called “levels”, which you can think of as categories. We can ask for the levels from the Class column by using the levels function. This function should return the name of each category in that column. Given that we only have 2 different values in our Class column (“B” and “M”), we only expect to get two names back. If we had 4 different values in the column, we would expect to get 4 back. Note the use of unlist to between select and levels. This is because select outputs a data frame (even though we only select a single column), and levels expects a vector. cancer %&gt;% select(Class) %&gt;% unlist() %&gt;% # turns a data frame into a vector levels() ## [1] &quot;B&quot; &quot;M&quot; Exploring the data Before we start doing any modelling, let’s explore our data set. Below we use the group_by + summarize code pattern we used before to see that we have 357 (63%) benign and 212 (37%) malignant tumour observations. num_obs &lt;- nrow(cancer) cancer %&gt;% group_by(Class) %&gt;% summarize(n = n(), percentage = n() / num_obs * 100) ## # A tibble: 2 x 3 ## Class n percentage ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; ## 1 B 357 62.7 ## 2 M 212 37.3 Next, let’s draw a scatter plot to visualize the relationship between the perimeter and concavity variables. Rather than use ggplot's default palette, we define our own here (cbPalette) and pass it as the values argument to the scale_color_manual function. We also make the category labels (“B” and “M”) more readable by changing them to “Benign” and “Malignant” using the labels argument. # colour palette cbPalette &lt;- c(&quot;#56B4E9&quot;, &quot;#E69F00&quot;,&quot;#009E73&quot;, &quot;#F0E442&quot;, &quot;#0072B2&quot;, &quot;#D55E00&quot;, &quot;#CC79A7&quot;, &quot;#999999&quot;) perim_concav &lt;- cancer %&gt;% ggplot(aes(x = Perimeter, y = Concavity, color = Class)) + geom_point(alpha = 0.5) + labs(color = &quot;Diagnosis&quot;) + scale_color_manual(labels = c(&quot;Benign&quot;, &quot;Malignant&quot;), values = cbPalette) perim_concav In this visualization, we can see that benign observations typically fall in the the lower left-hand side of the plot area. By contrast, malignant observations typically fall in upper right-hand side of the plot. Suppose we obtain a new observation not in the current data set that has all the variables measured except the label (i.e., an image without the physician’s diagnosis for the tumour class). We could compute the perimeter and concavity values, resulting in values of, say, 1 and 1. Could we use this information to classify that observation as benign or malignant? What about a new observation with perimeter value of -1 and concavity value of -0.5? What about 0 and 1? It seems like the prediction of an unobserved label might be possible, based on our visualization. In order to actually do this computationally in practice, we will need a classification algorithm; here we will use the K-nearest neighbour classification algorithm. 6.5 Classification with K-nearest neighbours To predict the label of a new observation, i.e., classify it as either benign or malignant, the K-nearest neighbour classifier generally finds the \\(K\\) “nearest” or “most similar” observations in our training set, and then uses their diagnoses to make a prediction for the new observation’s diagnosis. To illustrate this concept, we will walk through an example. Suppose we have a new observation, with perimeter of 2 and concavity of 4 (labelled in red on the scatterplot), whose diagnosis “Class” is unknown. We see that the nearest point to this new observation is malignant and located at the coordinates (2.3, 3.2). The idea here is that if a point is close to another in the scatterplot, then the perimeter and concavity values are similar, and so we may expect that they would have the same diagnosis. Suppose we have another new observation with perimeter 0.38 and concavity of 1.8. Looking at the scatterplot below, how would you classify this red observation? The nearest neighbour to this new point is a benign observation at (0.2, 1.8). Does this seem like the right prediction to make? Probably not, if you consider the other nearby points… So instead of just using the one nearest neighbour, we can consider several neighbouring points, say \\(K = 3\\), that are closest to the new red observation to predict its diagnosis class. Among those 3 closest points, we use the majority class as our prediction for the new observation. In this case, we see that the diagnoses of 2 of the 3 nearest neighbours to our new observation are malignant. Therefore we take majority vote and classify our new red observation as malignant. Here we chose the \\(K=3\\) nearest observations, but there is nothing special about \\(K=3\\). We could have used \\(K=4, 5\\) or more (though we may want to choose an odd number to avoid ties). We will discuss more about choosing \\(K\\) in the next chapter. Distance between points How do we decide which points are the \\(K\\) “nearest” to our new observation? We can compute the distance between any pair of points using the following formula: \\[\\mathrm{Distance} = \\sqrt{(x_a -x_b)^2 + (y_a - y_b)^2}\\] This formula – sometimes called the Euclidean distance – is simply the straight line distance between two points on the x-y plane with coordinates \\((x_a, y_a)\\) and \\((x_b, y_b)\\). Suppose we want to classify a new observation with perimeter of -1 and concavity of 4.2. Let’s calculate the distances between our new point and each of the observations in the training set to find the \\(K=5\\) observations in the training data that are nearest to our new point. new_obs_Perimeter &lt;- -1 new_obs_Concavity &lt;- 4.2 cancer %&gt;% select(ID, Perimeter, Concavity, Class) %&gt;% mutate(dist_from_new = sqrt((Perimeter - new_obs_Perimeter)^2 + (Concavity - new_obs_Concavity)^2)) %&gt;% arrange(dist_from_new) %&gt;% head(n = 5) ## # A tibble: 5 x 5 ## ID Perimeter Concavity Class dist_from_new ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 859471 -1.24 4.70 B 0.553 ## 2 84501001 -0.286 3.99 M 0.744 ## 3 8710441 -1.08 2.63 B 1.57 ## 4 9013838 -0.461 2.72 M 1.57 ## 5 925622 0.638 4.30 M 1.64 From this, we see that 3 of the 5 nearest neighbours to our new observation are malignant so classify our new observation as malignant. We circle those 5 in the plot below: It can be difficult sometimes to read code as math, so here we mathematically show the calculation of distance for each of the 5 closest points. Perimeter Concavity Distance Class -1.24 4.7 \\(\\sqrt{-1 - (-1.24))^2 + (4.2 - 4.7)^2}=\\) 0.55 B -0.29 3.99 \\(\\sqrt{(-1 - (-0.29))^2 + (4.2 - 3.99)^2} =\\) 0.74 M -1.08 2.63 \\(\\sqrt{(-1 - (-1.08))^2 + (4.2 - 2.63)^2} =\\) 1.57 B -0.46 2.72 \\(\\sqrt{(-1 - (-0.46))^2 + (4.2 - 2.72)^2} =\\) 1.57 M 0.64 4.3 \\(\\sqrt{(-1 - 0.64)^2 + (4.2 - 4.3)^2} =\\) 1.64 M More than two explanatory variables Although the above description is directed toward two explanatory variables / predictors, exactly the same K-nearest neighbour algorithm applies when you have a higher number of explanatory variables (i.e., a higher-dimensional predictor space). Each explanatory variable/predictor can give us new information to help create our classifier. The only difference is the formula for the distance between points. In particular, let’s say we have \\(m\\) predictor variables for two observations \\(u\\) and \\(v\\), i.e., \\(u = (u_{1}, u_{2}, \\dots, u_{m})\\) and \\(v = (v_{1}, v_{2}, \\dots, v_{m})\\). Before, we added up the squared difference between each of our (two) variables, and then took the square root; now we will do the same, except for all of our \\(m\\) variables. In other words, the distance formula becomes \\[Distance = \\sqrt{(u_{1} -v_{1})^2 + (u_{2} - v_{2})^2 + \\dots + (u_{m} - v_{m})^2}\\] Click and drag the plot above to rotate it, and scroll to zoom. Note that in general we recommend against using 3D visualizations; here we show the data in 3D only to illustrate what “higher dimensions” look like for learning purposes. Summary In order to classify a new observation using a K-nearest neighbour classifier, we have to: Compute the distance between the new observation and each observation in the training set Sort the data table in ascending order according to the distances Choose the top \\(K\\) rows of the sorted table Classify the new observation based on a majority vote of the neighbour classes 6.6 K-nearest neighbours in R Coding the K-nearest neighbour algorithm in R ourselves would get complicated if we might have to predict the label/class for multiple new observations, or when there are multiple classes and more than two variables. Thankfully, in R, the K-nearest neighbour algorithm is implemented in the caret package (classification and regression training). The caret library contains a set of tools to help make and use predictive models, such as classifiers. Using this package will help keep our code simple, readable and accurate; the less we have to code ourselves, the less mistakes we are likely to make. We start off by loading the caret library: library(caret) Let’s again suppose we have a new observation with perimeter -1 and concavity 4.2, but its diagnosis is unknown (as in our example above). Suppose we again want to use the perimeter and concavity explanatory variables/predictors to predict the diagnosis class of this observation. Let’s pick out our 2 desired variables and store it as a new dataset named cancer_train: cancer_train &lt;- cancer %&gt;% select(&quot;Perimeter&quot;, &quot;Concavity&quot;) head(cancer_train) ## # A tibble: 6 x 2 ## Perimeter Concavity ## &lt;dbl&gt; &lt;dbl&gt; ## 1 2.30 2.11 ## 2 1.53 -0.147 ## 3 1.35 0.854 ## 4 -0.250 1.99 ## 5 1.34 0.613 ## 6 -0.115 1.26 Next, we store the diagnosis class labels (column Class) as a vector: cancer_labels &lt;- cancer %&gt;% select(Class) %&gt;% unlist() head(cancer_labels) ## Class1 Class2 Class3 Class4 Class5 Class6 ## M M M M M M ## Levels: B M We will use the function train(), where: x is a data frame object containing the explanatory variables/predictors, y is a numeric or factor vector containing the outcomes/labels/classes, method is the type of prediction algorithm we want to use, we will use “knn”, and tuneGrid is a data frame with possible “tuning values”. For now, just know that this is where we will specify \\(K=5\\) (the number of nearest neighbours to vote on the predicted class). The arguments x and y should come from the original data frame and be in the same order. We will also discuss how to choose \\(K\\) in the next chapter. k &lt;- data.frame(k = 5) model_knn &lt;- train(x = data.frame(cancer_train), y = cancer_labels, method=&#39;knn&#39;, tuneGrid = k) Note: the caret package expects data.frames and not tibbles (a special kind of data frames). This is a bit annoying, and will likely change in the future, but for now we have to change tibbles to data.frames when using caret. Now we can create a data.frame with our new observation and predict the label of the new observation using the predict function: new_obs &lt;- data.frame(Perimeter = -1, Concavity = 4.2) predict(object = model_knn, new_obs) ## [1] M ## Levels: B M Our model classifies this new observation as malignant. In the next chapter, we will discuss evaluating how accurate our predictions are, and selecting the value of \\(K\\) to maximize that accuracy. 6.7 Data preprocessing 6.7.1 Shifting and scaling When using K-nearest neighbour classification, the scale of each variable (i.e., its size and range of values) matters. Since the classifier predicts classes by identifying observations that are nearest to it, any variables that have a large scale will have a much larger effect than variables with a small scale. But just because a variable has a large scale doesn’t mean that it is more important for making accurate predictions. For example, suppose you have a data set with two attributes, salary (in dollars) and years of education, and you want to predict the corresponding type of job. When we compute the neighbour distances, a difference of $1000 is huge compared to a difference of 10 years of education. But for our conceptual understanding and answering of the problem, it’s the opposite; 10 years of education is huge compared to a difference of $1000 in yearly salary! In many other predictive models, the center of each variable (e.g., its mean) matters as well. For example, if we had a data set with a temperature variable measured in degrees Kelvin, and the same data set with temperature measured in degrees Celcius, the two variables would differ by a constant shift of 273 (even though they contain exactly the same information). Likewise in our hypothetical job classification example, we would likely see that the center of the salary variable is in the tens of thousands, while the center of the years of education variable is in the single digits. Although this doesn’t affect the K-nearest neighbour classification algorithm, this large shift can change the outcome of using many other predictive models. Standardization: when all variables in a data set have a mean (center) of 0 and a standard deviation (scale) of 1, we say that the data have been standardized. To illustrate the effect that standardization can have on the K-nearest neighbour algorithm, we will read in the original, unscaled Wisconsin breast cancer data set; we have been using a standardized version of the data set up until now. In order to do this we will download the raw data from the UCI Machine learning repository, and then compute the unscaled columns equivalent to those we have been working with in the scaled version of the data set (“worst” measures). unscaled_cancer &lt;- read_csv(&quot;https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/wdbc.data&quot;, col_names = FALSE) %&gt;% select(X1, X2, X11:X20) ## Parsed with column specification: ## cols( ## .default = col_double(), ## X2 = col_character() ## ) ## See spec(...) for full column specifications. colnames(unscaled_cancer) &lt;- colnames(cancer) head(unscaled_cancer) ## # A tibble: 6 x 12 ## ID Class Radius Texture Perimeter Area Smoothness Compactness ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 8.42e5 M 0.242 0.0787 1.10 0.905 8.59 153. ## 2 8.43e5 M 0.181 0.0567 0.544 0.734 3.40 74.1 ## 3 8.43e7 M 0.207 0.0600 0.746 0.787 4.58 94.0 ## 4 8.43e7 M 0.260 0.0974 0.496 1.16 3.44 27.2 ## 5 8.44e7 M 0.181 0.0588 0.757 0.781 5.44 94.4 ## 6 8.44e5 M 0.209 0.0761 0.334 0.890 2.22 27.2 ## # … with 4 more variables: Concavity &lt;dbl&gt;, Concave_points &lt;dbl&gt;, ## # Symmetry &lt;dbl&gt;, Fractal_dimension &lt;dbl&gt; Looking at the unscaled / unshifted data above, you can see that the difference between the values for smoothness measurements are much larger than those for area, and the mean appears to be much larger too. Will this affect predictions? In order to find out, we will create a scatter plot of these two predictors (coloured by diagnosis) for both the unstandardized data we just downloaded, and the standardized version of that same data. In order to standardize the unscaled_cancer data, we will use the scale function in R, passing TRUE to the center argument: scaled_cancer &lt;- unscaled_cancer %&gt;% select(-c(ID,Class)) %&gt;% scale(center = TRUE) scaled_cancer &lt;- data.frame(ID = unscaled_cancer$ID, Class = unscaled_cancer$Class, scaled_cancer) head(scaled_cancer) ## ID Class Radius Texture Perimeter Area Smoothness ## 1 842302 M 2.215565542 2.2537638 2.4875451 -0.5647681 2.8305403 ## 2 842517 M 0.001391139 -0.8678888 0.4988157 -0.8754733 0.2630955 ## 3 84300903 M 0.938858720 -0.3976580 1.2275958 -0.7793976 0.8501802 ## 4 84348301 M 2.864862154 4.9066020 0.3260865 -0.1103120 0.2863415 ## 5 84358402 M -0.009552062 -0.5619555 1.2694258 -0.7895490 1.2720701 ## 6 843786 M 1.004517928 1.8883435 -0.2548461 -0.5921406 -0.3210217 ## Compactness Concavity Concave_points Symmetry Fractal_dimension ## 1 2.4853907 -0.2138135 1.31570389 0.7233897 0.66023900 ## 2 0.7417493 -0.6048187 -0.69231710 -0.4403926 0.25993335 ## 3 1.1802975 -0.2967439 0.81425704 0.2128891 1.42357487 ## 4 -0.2881246 0.6890953 2.74186785 0.8187979 1.11402678 ## 5 1.1893103 1.4817634 -0.04847723 0.8277425 1.14319885 ## 6 -0.2890039 0.1562093 0.44515196 0.1598845 -0.06906279 Now let’s generate the two scatter plots, one for unscaled_cancer and one for scaled_cancer, and show them side-by-side: In the plot with the original data above, its very clear that K-nearest neighbours would classify the red dot (new observation) as malignant. However, once we standardize the data, the diagnosis class labelling becomes less clear, and appears it would depend upon the choice of \\(K\\). Thus, standardizing the data can change things in an important way when we are using predictive algorithms. As a rule of thumb, standardizing your data should be a part of the preprocessing you do before any predictive modelling / analysis. 6.7.2 Balancing Another potential issue in a data set for a classifier is class imbalance, i.e., when one label is much more common than another. Since classifiers like the K-nearest neighbour algorithm use the labels of nearby points to predict the label of a new point, if there are many more data points with one label overall, the algorithm is more likely to pick that label in general (even if the “pattern” of data suggests otherwise). Class imbalance is actually quite a common and important problem: from rare disease diagnosis to malicious email detection, there are many cases in which the “important” class to identify (presence of disease, malicious email) is much rarer than the “unimportant” class (no disease, normal email). To better illustrate the problem, let’s revisit the breast cancer data; except now we will remove many of the observations of malignant tumours, simulating what the data would look like if the cancer was rare. We will do this by picking only 3 observations randomly from the malignant group, and keeping all of the benign observations. set.seed(1) rare_cancer &lt;- bind_rows(filter(cancer, Class == &quot;B&quot;), cancer %&gt;% filter(Class == &quot;M&quot;) %&gt;% sample_n(3) ) rare_plot &lt;- rare_cancer %&gt;% ggplot(aes(x = Perimeter, y = Concavity, color = Class)) + geom_point(alpha = 0.5) + labs(color = &quot;Diagnosis&quot;) + scale_color_manual(labels = c(&quot;Benign&quot;, &quot;Malignant&quot;), values = cbPalette) rare_plot Note: You will see in the code above that we use the set.seed function. This is because we are using sample_n to artificially pick only 3 of the malignant tumour observations, which uses random sampling to choose which rows will be in the training set. In order to make the code reproducible, we use set.seed to specify where the random number generator starts for this process, which then guarantees the same result, i.e., the same choice of 3 observations, each time the code is run. In general, when your code involves random numbers, if you want the same result each time, you should use set.seed; if you want a different result each time, you should not. Suppose we now decided to use \\(K = 7\\) in K-nearest neighbour classification. With only 3 observations of malignant tumours, the classifier will always predict that the tumour is benign, no matter what its concavity and perimeter are! This is because in a majority vote of 7 observations, at most 3 will be malignant (we only have 3 total malignant observations), so at least 4 must be benign, and the benign vote will always win. For example, look what happens for a new tumour observation that is quite close to two that were tagged as malignant: And if we set the background colour of each area of the plot to the decision the K-nearest neighbour classifier would make, we can see that the decision is always “benign,” corresponding to the blue colour: Despite the simplicity of the problem, solving it in a statistically sound manner is actually fairly nuanced, and a careful treatment would require a lot more detail and mathematics than we will cover in this textbook. For the present purposes, it will suffice to rebalance the data by oversampling the rare class. In other words, we will replicate rare observations multiple times in our data set to give them more voting power in the K-nearest neighbour algorithm. In order to do this, we will use the upSample function from the caret library. We show below how to do this, and also use the group_by + summarize pattern we’ve seen before to see that our classes are now balanced: rare_cancer &lt;- upSample(x = select(rare_cancer, Perimeter, Concavity), y = select(rare_cancer, Class) %&gt;% unlist() ) rare_cancer %&gt;% group_by(Class) %&gt;% summarize(n = n()) ## # A tibble: 2 x 2 ## Class n ## &lt;fct&gt; &lt;int&gt; ## 1 B 357 ## 2 M 357 Now suppose we train our K-nearest neighbour classifier with \\(K=7\\) on this balanced data. Setting the background colour of each area of our scatter plot to the decision the K-nearest neighbour classifier would make, we can see that the decision is more reasonable; when the points are close to those labelled malignant, the classifier predicts a malignant tumour, and vice versa when they are closer to the benign tumour observations: "],
["classification-continued.html", "Chapter 7 Classification II: Evaluation &amp; tuning 7.1 Overview 7.2 Chapter learning objectives 7.3 Evaluating accuracy 7.4 Tuning the classifier 7.5 Splitting data 7.6 Summary", " Chapter 7 Classification II: Evaluation &amp; tuning 7.1 Overview This chapter continues the introduction to predictive modelling through classification. While the previous chapter covered training and data preprocessing, this chapter focuses on how to split data, how to evaluate prediction accuracy, and how to choose model parameters to maximize performance. 7.2 Chapter learning objectives By the end of the chapter, students will be able to: Describe what training, validation, and test data sets are and how they are used in classification Split data into training, validation, and test data sets Evaluate classification accuracy in R using a validation data set and appropriate metrics Execute cross-validation in R to choose the number of neighbours in a K-nearest neighbour classifier Describe advantages and disadvantages of the K-nearest neighbour classification algorithm 7.3 Evaluating accuracy Sometimes our classifier might make the wrong prediction. A classifier does not need to be right 100% of the time to be useful, though we don’t want the classifier to make too many wrong predictions. How do we measure how “good” our classifier is? Let’s revisit the Wisconsin breast cancer example and think about how our classifier will be used in practice. A biopsy will be performed on a new patient’s tumour, the resulting image will be analyzed, and the classifier will be asked to decide whether the tumour is benign or malignant. The key word here is new: our classifier is “good” if it provides accurate predictions on data not seen during training. But then how can we evaluate our classifier without having to visit the hospital to collect more tumour images? The trick is to split up the data set into a training set and test set, and only show the classifier the training set when building the classifier. Then to evaluate the accuracy of the classifier, we can use it to predict the labels (which we know) in the test set. If our predictions match the true labels for the observations in the test set very well, then we have some confidence that our classifier might also do a good job of predicting the class labels for new observations that we do not have the class labels for. Note: if there were a golden rule of machine learning, it might be this: you cannot use the test data to build the model! If you do, the model gets to “see” the test data in advance, making it look more accurate than it really is. Imagine how bad it would be to overestimate your classifier’s accuracy when predicting whether a patient’s tumour is malignant or benign! How exactly can we assess how well our predictions match the true labels for the observations in the test set? One way we can do this is to calculate the prediction accuracy. This is the fraction of examples for which the classifier made the correct prediction. To calculate this we divide the number of correct predictions by the number of predictions made. Other measures for how well our classifier performed include precision and recall; these will not be discussed here, but you will encounter them in other more advanced courses on this topic. This process is illustrated below: In R, we can use the caret package not only to perform K-nearest neighbour classification, but also to assess how well our classification worked. Let’s start by loading the necessary libraries, reading in the breast cancer data from the previous chapter, and making a quick scatter plot visualization of tumour cell concavity versus smoothness coloured by diagnosis. # load libraries library(tidyverse) library(caret) #load data cancer &lt;- read_csv(&quot;data/clean-wdbc.data.csv&quot;) %&gt;% mutate(Class = as.factor(Class)) # because we will be doing statistical analysis on a categorical variable # colour palette cbPalette &lt;- c(&quot;#56B4E9&quot;, &quot;#E69F00&quot;,&quot;#009E73&quot;, &quot;#F0E442&quot;, &quot;#0072B2&quot;, &quot;#D55E00&quot;, &quot;#CC79A7&quot;, &quot;#999999&quot;) # create scatter plot of tumour cell concavity versus smoothness, # labelling the points be diagnosis class perim_concav &lt;- cancer %&gt;% ggplot(aes(x = Smoothness, y = Concavity, color = Class)) + geom_point(alpha = 0.5) + labs(color = &quot;Diagnosis&quot;) + scale_color_manual(labels = c(&quot;Benign&quot;, &quot;Malignant&quot;), values = cbPalette) perim_concav 1. Create the train / test split Once we have decided on a predictive question to answer and done some preliminary exploration, the very next thing to do is to split the data into the training and test sets. Typically, the training set is between 50 - 100% of the data, while the test set is the remaining 0 - 50%; the intuition is that you want to trade off between training an accurate model (by using a larger training data set) and getting an accurate evaluation of its performance (by using a larger test data set). Here, we will use 75% of the data for training, and 25% for testing. To do this we will use the createDataPartition function from the caret package, specifying values for 3 arguments: y: the class labels. These must be a vector. p: the proportion (between 0 and 1) of the data you would like in the training data set. list = FALSE: this states that we want the training and test sets in the form of a matrix, not a list. The createDataPartition function returns the row numbers for the training set. set.seed(1) # makes the random selection of rows reproducible set_rows &lt;- cancer %&gt;% select(Class) %&gt;% unlist() %&gt;% # converts Class from a tibble to a vector createDataPartition(p = 0.75, list = FALSE) head(set_rows) ## Resample1 ## [1,] 1 ## [2,] 2 ## [3,] 3 ## [4,] 4 ## [5,] 5 ## [6,] 6 Note: You will see in the code above that we use the set.seed function again, as discussed in the previous chapter. In this case it is because createDataPartition uses random sampling to choose which rows will be in the training set. Since we want our code to be reproducible and generate the same train/test split each time it is run, we use set.seed. Now that we have the row numbers for the training set, we can use the slice function to get the rows from the original data set (here cancer) to create the training and test data sets. training_set &lt;- cancer %&gt;% slice(set_rows) test_set &lt;- cancer %&gt;% slice(-set_rows) glimpse(training_set) ## Observations: 427 ## Variables: 12 ## $ ID &lt;dbl&gt; 842302, 842517, 84300903, 84348301, 84358402, … ## $ Class &lt;fct&gt; M, M, M, M, M, M, M, M, M, M, M, M, M, M, M, B… ## $ Radius &lt;dbl&gt; 1.8850310, 1.8043398, 1.5105411, -0.2812170, 1… ## $ Texture &lt;dbl&gt; -1.35809849, -0.36887865, -0.02395331, 0.13386… ## $ Perimeter &lt;dbl&gt; 2.30157548, 1.53377643, 1.34629062, -0.2497195… ## $ Area &lt;dbl&gt; 1.99947816, 1.88882702, 1.45500430, -0.5495376… ## $ Smoothness &lt;dbl&gt; 1.306536657, -0.375281748, 0.526943750, 3.3912… ## $ Compactness &lt;dbl&gt; 2.61436466, -0.43006581, 1.08198014, 3.8899746… ## $ Concavity &lt;dbl&gt; 2.10767182, -0.14661996, 0.85422232, 1.9878391… ## $ Concave_points &lt;dbl&gt; 2.2940576, 1.0861286, 1.9532817, 2.1738732, 0.… ## $ Symmetry &lt;dbl&gt; 2.7482041, -0.2436753, 1.1512420, 6.0407261, -… ## $ Fractal_dimension &lt;dbl&gt; 1.93531174, 0.28094279, 0.20121416, 4.93067187… glimpse(test_set) ## Observations: 142 ## Variables: 12 ## $ ID &lt;dbl&gt; 84501001, 846381, 84799002, 849014, 852763, 85… ## $ Class &lt;fct&gt; M, M, M, M, M, M, M, B, M, M, M, B, B, B, B, B… ## $ Radius &lt;dbl&gt; -0.24397494, 0.11810090, 0.24637920, 2.2864179… ## $ Texture &lt;dbl&gt; 2.440961268, 0.322599039, 1.863374024, 0.84649… ## $ Perimeter &lt;dbl&gt; -0.286026354, 0.141024667, 0.501116469, 2.3670… ## $ Area &lt;dbl&gt; -0.297147713, -0.007171473, 0.109978225, 2.665… ## $ Smoothness &lt;dbl&gt; 2.31825554, -0.84391344, 1.55180184, 0.8247657… ## $ Compactness &lt;dbl&gt; 5.10838243, -0.39320214, 2.56415380, 0.3860195… ## $ Concavity &lt;dbl&gt; 3.99192038, -0.19167703, 2.06309407, 1.2702812… ## $ Concave_points &lt;dbl&gt; 1.61859101, -0.04117035, 0.86097309, 1.8893861… ## $ Symmetry &lt;dbl&gt; 2.36835989, -0.14831011, 2.12913885, -0.214580… ## $ Fractal_dimension &lt;dbl&gt; 6.84083682, -1.16690689, 2.77689167, -0.431631… We can see from glimpse in the code above that the training set contains 427 observations, while the test set contains 142 observations. This corresponds to a train / test split of 75% / 25%, as desired. 2. Train the classifier Now that we have split our original data set into training and test sets, we can create our K-nearest neighbour classifier with only the training set using the technique we learned in the previous chapter. For now, we will just choose the number \\(K\\) of neighbours to be 3, and use concavity and smoothness as the predictors. X_train &lt;- training_set %&gt;% select(Concavity, Smoothness) %&gt;% data.frame() Y_train &lt;- training_set %&gt;% select(Class) %&gt;% unlist() k = data.frame(k = 3) set.seed(1) model_knn &lt;- train(x = X_train, y = Y_train, method = &quot;knn&quot;, tuneGrid = k) model_knn ## k-Nearest Neighbors ## ## 427 samples ## 2 predictor ## 2 classes: &#39;B&#39;, &#39;M&#39; ## ## No pre-processing ## Resampling: Bootstrapped (25 reps) ## Summary of sample sizes: 427, 427, 427, 427, 427, 427, ... ## Resampling results: ## ## Accuracy Kappa ## 0.8199217 0.6181178 ## ## Tuning parameter &#39;k&#39; was held constant at a value of 3 Note: Here again you see the set.seed function. In the K-nearest neighbour implementation in caret, when there is a tie for the majority neighbour class, the winner is randomly selected. Although there is no chance of a tie when \\(K\\) is odd (here \\(K=3\\)), it is possible that the code may be changed in the future to have an even value of \\(K\\). Thus, to prevent potential issues with reproducibility, we have set the seed. Note that in your own code, you only have to set the seed once at the beginning of your analysis. 3. Predict the labels in the test set Now that we have a K-nearest neighbour classifier object, we can use it to predict the class labels for our test set: X_test &lt;- test_set %&gt;% select(Concavity, Smoothness) %&gt;% data.frame() Y_test_predicted &lt;- predict(object = model_knn, X_test) head(Y_test_predicted) ## [1] M B M M M M ## Levels: B M 4. Compute the accuracy Finally we can assess our classifier’s accuracy. To do this we need to create a vector containing the class labels for the test set. Next we use the function confusionMatrix to get the statistics about the quality of our model, this includes the statistic we are interested: accuracy. confusionMatrix takes two arguments: data (the predicted class labels for the test set), and reference (the original/measured class labels for the test set). Y_test &lt;- test_set %&gt;% select(Class) %&gt;% unlist() model_quality &lt;- confusionMatrix(data = Y_test_predicted, reference = Y_test) model_quality ## Confusion Matrix and Statistics ## ## Reference ## Prediction B M ## B 81 16 ## M 8 37 ## ## Accuracy : 0.831 ## 95% CI : (0.759, 0.8886) ## No Information Rate : 0.6268 ## P-Value [Acc &gt; NIR] : 8.459e-08 ## ## Kappa : 0.6274 ## ## Mcnemar&#39;s Test P-Value : 0.153 ## ## Sensitivity : 0.9101 ## Specificity : 0.6981 ## Pos Pred Value : 0.8351 ## Neg Pred Value : 0.8222 ## Prevalence : 0.6268 ## Detection Rate : 0.5704 ## Detection Prevalence : 0.6831 ## Balanced Accuracy : 0.8041 ## ## &#39;Positive&#39; Class : B ## A lot of information is output from confusionMatrix, but what we are interested in at this point is accuracy (found on the 6th line of printed output). That single value can be obtained from the confusionMatrix object using base/built-in R subsetting: model_quality$overall[1] ## Accuracy ## 0.8309859 From a value of accuracy of around 0.824, we can say that our K-nearest neighbour classifier predicted the correct class label on roughly 82% of the examples. 7.4 Tuning the classifier The vast majority of predictive models in statistics and machine learning have parameters that you have to pick. For example, in the K-nearest neighbour classification algorithm we have been using in the past two chapters, we have had to pick the number of neighbours \\(K\\) for the class vote. Is it possible to make this selection, i.e., tune the model, in a principled way? Ideally what we want is to somehow maximize the performance of our classifier on data it hasn’t seen yet. So we will play the same trick we did before when evaluating our classifier: we’ll split our overall training data set further into two subsets, called the training set and validation set. We will use the newly-named training set for building the classifier, and the validation set for evaluating it! Then we will try different values of the parameter \\(K\\) and pick the one that yields the highest accuracy. Remember: don’t touch the test set during the tuning process. Tuning is a part of model training! 7.4.1 Cross-validation There is an important detail to mention about the process of tuning: we can, if we want to, split our overall training data up in multiple different ways, train and evaluate a classifier for each split, and then choose the parameter based on all of the different results. If we just split our overall training data once, our best parameter choice will depend strongly on whatever data was lucky enough to end up in the validation set. Perhaps using multiple different train / validation splits, we’ll get a better estimate of accuracy, which will lead to a better choice of the number of neighbours \\(K\\) for the overall set of training data. Note: you might be wondering why we can’t we use the multiple splits to test our final classifier after tuning is done. This is simply because at the end of the day, we will produce a single classifier using our overall training data. If we do multiple train / test splits, we will end up with multiple classifiers, each with their own accuracy evaluated on different test data! Let’s investigate this idea in R! In particular, we will use different seed values in the set.seed function to generate five different train / validation splits of our overall training data, train five different K-nearest neighbour models, and evaluate their accuracy. First we’ll rename our overall training data. X_train_total &lt;- X_train Y_train_total &lt;- Y_train Then we’ll try 5 different random train / validation splits of the data and record the accuracy: accuracies &lt;- c() for (i in 1:5){ set.seed(i) # makes the random selection of rows reproducible # create the 75 / 25 train/validation split set_rows &lt;- Y_train_total %&gt;% createDataPartition(p = 0.75, list = FALSE) #split the X and Y data into train/validation X_train &lt;- X_train_total %&gt;% slice(set_rows) Y_train &lt;- Y_train_total[set_rows] X_validation &lt;- X_train_total %&gt;% slice(-set_rows) Y_validation &lt;- Y_train_total[-set_rows] #train the KNN model with K=3, and predict the validation labels k = data.frame(k = 3) model_knn &lt;- train(x = X_train, y = Y_train, method = &quot;knn&quot;, tuneGrid = k) Y_validation_predicted &lt;- predict(object = model_knn, X_validation) #compute the accuracy model_quality &lt;- confusionMatrix(data = Y_validation_predicted, reference = Y_validation) accuracies &lt;- append(accuracies, model_quality$overall[1]) } accuracies ## Accuracy Accuracy Accuracy Accuracy Accuracy ## 0.8207547 0.8018868 0.8301887 0.8396226 0.8679245 With five different shuffles of the data, we get five different values for accuracy: 0.83, 0.88, 0.84, 0.82, and 0.89! None of these is necessarily “more correct” than any other; they’re just five estimates of the true, underlying accuracy of our classifier built using our overall training data. We can combine the estimates by taking their average (here 0.851) to try to get a single assessment of our classifier’s accuracy; this has the effect of reducing the influence of any one (un)lucky validation set on the estimate. In practice, we don’t use random splits, but rather use a more structured splitting procedure so that each observation in the data set is used in a validation set only a single time. The name for this strategy is called cross-validation. In cross-validation, we split our overall training data into \\(C\\) evenly-sized chunks, and then iteratively use \\(1\\) chunk as the validation set and combine the remaining \\(C-1\\) chunks as the training set: In the picture above, \\(C=5\\) different chunks of the data set are used, resulting in 5 different choices for the validation set; we call this 5-fold cross-validation. To do 5-fold cross-validation in R with caret, we use another function called trainControl. This function passes additional information to the train function we use to create our classifier. The arguments we pass trainControl are: method=&quot;cv&quot;: specifies to use cross-validation for assessing quality number: how many chunks to split the data into for cross validation train_control &lt;- trainControl(method=&quot;cv&quot;, number = 5) Then, when we create our classifier, we add an additional argument to train called trControl, which we set to the train_control object we just created. One benefit of using caret for this is that we do not need to manually do any of the work of cross-validation ourselves; the train function will handle creating the chunks, doing multiple rounds of training and evaluation, and averaging the results for us. set.seed(1234) k = data.frame(k = 3) knn_model_cv_5fold &lt;- train(x = X_train_total, y = Y_train_total, method = &quot;knn&quot;, tuneGrid = k, trControl = train_control) knn_model_cv_5fold ## k-Nearest Neighbors ## ## 427 samples ## 2 predictor ## 2 classes: &#39;B&#39;, &#39;M&#39; ## ## No pre-processing ## Resampling: Cross-Validated (5 fold) ## Summary of sample sizes: 341, 342, 341, 342, 342 ## Resampling results: ## ## Accuracy Kappa ## 0.8478249 0.6758599 ## ## Tuning parameter &#39;k&#39; was held constant at a value of 3 Note: we set the seed when we call train not only because of the potential for ties, but also because we are doing cross-validation. Cross-validation uses a random process to select how to partition the training data. We can choose any number of folds, and typically the more we use the better our accuracy estimate will be. However, we are limited by computational power: the more folds we choose, the more computation it takes, and hence the more time it takes to run the analysis. So when you do cross-validation, you need to consider the size of the data, and the speed of the algorithm (e.g., K-nearest neighbour) and the speed of your computer. In practice, this is a trial and error process, but typically \\(C\\) is chosen to be either 5 or 10. Here we show what happens when we split the data into 10 chunks and do 10-fold cross-validation: train_control &lt;- trainControl(method=&quot;cv&quot;, number = 10) set.seed(1234) knn_model_cv_10fold &lt;- train(x = X_train_total, y = Y_train_total, method = &quot;knn&quot;, tuneGrid = k, trControl = train_control) knn_model_cv_10fold ## k-Nearest Neighbors ## ## 427 samples ## 2 predictor ## 2 classes: &#39;B&#39;, &#39;M&#39; ## ## No pre-processing ## Resampling: Cross-Validated (10 fold) ## Summary of sample sizes: 384, 385, 384, 384, 384, 385, ... ## Resampling results: ## ## Accuracy Kappa ## 0.8454596 0.6710972 ## ## Tuning parameter &#39;k&#39; was held constant at a value of 3 7.4.2 Parameter value selection Using 5- and 10-fold cross-validation, we have estimated that the prediction accuracy of our classifier is somewhere around 85%. Whether 85% is good or not depends entirely on the downstream application of the data analysis. In the present situation, we are trying to predict a tumour diagnosis, with expensive, damaging chemo/radiation therapy or patient death as potential consequences of misprediction. Hence, we’d like to do better than 85% for this application. In order to improve our classifier, we have one choice of parameter: the number of neighbours, \\(K\\). Since cross-validation helps us evaluate the accuracy of our classifier, we can use cross-validation to calculate an accuracy for each value of \\(K\\) in a reasonable range, and then pick the value of \\(K\\) that gives us the best accuracy. In R, we can accomplish this tuning by passing a vector of values for \\(K\\) to the tuneGrid argument of train. train_control &lt;- trainControl(method=&quot;cv&quot;, number = 10) k = data.frame(k = c(1, 3, 5, 7, 9, 11, 13, 15, 17)) set.seed(1234) knn_model_cv_10fold &lt;- train(x = X_train_total, y = Y_train_total, method = &quot;knn&quot;, tuneGrid = k, trControl = train_control) knn_model_cv_10fold ## k-Nearest Neighbors ## ## 427 samples ## 2 predictor ## 2 classes: &#39;B&#39;, &#39;M&#39; ## ## No pre-processing ## Resampling: Cross-Validated (10 fold) ## Summary of sample sizes: 384, 385, 384, 384, 384, 385, ... ## Resampling results across tuning parameters: ## ## k Accuracy Kappa ## 1 0.7822259 0.5399610 ## 3 0.8454596 0.6710972 ## 5 0.8571982 0.6953918 ## 7 0.8524917 0.6865957 ## 9 0.8455150 0.6718312 ## 11 0.8477852 0.6774676 ## 13 0.8524363 0.6862592 ## 15 0.8548173 0.6916750 ## 17 0.8524917 0.6880031 ## ## Accuracy was used to select the optimal model using the largest value. ## The final value used for the model was k = 5. Although caret provides a selection of \\(K=11\\) for us by maximizing the accuracy estimate, it is helpful regardless to visualize the accuracy as we increase \\(K\\). We can access the results from the cross-validation via theresults attribute of the train object (our classifier). accuracies &lt;- knn_model_cv_10fold$results accuracies ## k Accuracy Kappa AccuracySD KappaSD ## 1 1 0.7822259 0.5399610 0.05826102 0.12281985 ## 2 3 0.8454596 0.6710972 0.04946712 0.10552753 ## 3 5 0.8571982 0.6953918 0.04028401 0.08658811 ## 4 7 0.8524917 0.6865957 0.04668649 0.09880647 ## 5 9 0.8455150 0.6718312 0.04780184 0.10268310 ## 6 11 0.8477852 0.6774676 0.04958268 0.10452620 ## 7 13 0.8524363 0.6862592 0.05065041 0.10756692 ## 8 15 0.8548173 0.6916750 0.05150580 0.10941369 ## 9 17 0.8524917 0.6880031 0.04531724 0.09636354 Now we can plot accuracy versus \\(K\\): accuracy_vs_k &lt;- ggplot(accuracies, aes(x = k, y = Accuracy)) + geom_point() + geom_line() accuracy_vs_k Based off of the visualization above, we might agree with caret’s choice of \\(K=11\\). But as you can see, there is no exact or perfect answer here; any choice between \\(K=8\\) and \\(K = 15\\) would be reasonably justified. Remember: the values you see on this plot are estimates of the true accuracy of our classifier. Although the \\(K=11\\) value is higher than the others on this plot, that doesn’t mean the classifier is actually more accurate with this parameter value! Generally, when selecting \\(K\\) (and other parameters for other predictive models), we are looking for a value where: we get roughly optimal accuracy, so that our model will likely be accurate changing the value to a nearby one (e.g. from \\(K=11\\) to 10 or 12) doesn’t decrease accuracy too much, so that our choice is reliable in the presence of uncertainty the cost of training the model is not prohibitive (e.g., in our situation, if \\(K\\) is too large, predicting becomes expensive!) 7.4.3 Under/overfitting To build a bit more intuition, what happens if we keep increasing the number of neighbours \\(K\\)? In fact, the accuracy actually starts to decrease! Take a look as the plot below as we vary \\(K\\) from 1 to almost the number of observations in the data set: train_control &lt;- trainControl(method=&quot;cv&quot;, number = 10) k_lots = data.frame(k = seq(from = 1, to = 385, by = 10)) set.seed(1234) knn_model_cv_10fold_lots &lt;- train(x = X_train_total, y = Y_train_total, method = &quot;knn&quot;, tuneGrid = k_lots, trControl = train_control) accuracies_lots &lt;- knn_model_cv_10fold_lots$results accuracy_vs_k_lots &lt;- ggplot(accuracies_lots, aes(x = k, y = Accuracy)) + geom_point() + geom_line() accuracy_vs_k_lots Underfitting: What is actually happening to our classifier that causes this? As we increase the number of neighbours, more and more of the training observations (and those that are farther and farther away from the point) get a “say” in what the class of a new observation is. This causes a sort of “averaging effect” to take place, making the boundary between where our classifier would predict a tumour to be malignant versus benign to smooth out and become simpler. If you take this to the extreme, setting \\(K\\) to the total training data set size, then the classifier will always predict the same label regardless of what the new observation looks like. In general, if the model isn’t influenced enough by the training data, it is said to underfit the data. Overfitting: In contrast, when we decrease the number of neighbours, each individual data point has a stronger and stronger vote regarding nearby points. Since the data themselves are noisy, this causes a more “jagged” boundary corresponding to a less simple model. If you take this case to the extreme, setting \\(K = 1\\), then the classifier is essentially just matching each new observation to its closest neighbour in the training data set. This is just as problematic as the large \\(K\\) case, because the classifier becomes unreliable on new data: if we had a different training set, the predictions would be completely different. In general, if the model is influenced too much by the training data, it is said to overfit the data. You can see this effect in the plots below as we vary the number of neighbours \\(K\\) in (1, 7, 20, 200): 7.5 Splitting data Shuffling: When we split the data into train, test, and validation sets, we make the assumption that there is no order to our originally collected data set. However, if we think that there might be some order to the original data set, then we can randomly shuffle the data before splitting it. The caret package’s createDataPartition function does this for us. Stratification: If the data are imbalanced, we also need to be extra careful about splitting the data to ensure that enough of each class ends up in each of the train, validation, and test partitions. Luckily, the createDataPartition does this for us as well. 7.6 Summary Classification algorithms use one or more quantitative variables to predict the value of a third, categorical variable. The K-nearest neighbour algorithm in particular does this by first finding the K points in the training data nearest to the new observation, and then returning the majority class vote from those training observations. We can evaluate a classifier by splitting the data randomly into a training and test data set, using the training set to build the classifier, and using the test set to estimate its accuracy. To tune the classifier (e.g., select the K in K-nearest neighbours), we maximize accuracy estimates from cross-validation. A typical 10-fold cross-validation data set split. Source: https://towardsdatascience.com/train-test-split-and-cross-validation-in-python-80b61beca4b6 The overall workflow for performing K-nearest neighbour classification in caret is as follows: Use the createDataPartition function to split the data into a training and test set. Put the test set aside for now. Use the trainControl function to specify whether to use cross-validation and how many folds Use the train function to train and evaluate the classifier for different values of \\(K\\) Retrain the classifier on all the training data, using the best parameter from the previous step Evaluate the estimated accuracy of the classifier on the test set Strengths: Simple and easy to understand No assumptions about what the data must look like Works easily for binary (two-class) and multi-class (&gt; 2 classes) classification problems Weaknesses: As data gets bigger and bigger, K-nearest neighbour gets slower and slower, quite quickly Does not perform well with a large number of predictors Does not perform well when classes are imbalanced (when many more observations are in one of the classes compared to the others) "],
["regression1.html", "Chapter 8 Introduction to regression through K-nearest neighbours 8.1 Overview 8.2 Chapter learning objectives 8.3 Regression 8.4 Sacremento real estate example 8.5 K-nearest neighbours regression 8.6 Assessing a knn regression model 8.7 How do different k’s affect k-nn regression predictions 8.8 Assessing how well the model predicts on unseen data with the test set 8.9 Strengths and limitations of k-nn regression 8.10 Multivariate k-nn regression", " Chapter 8 Introduction to regression through K-nearest neighbours 8.1 Overview Introduction to regression using K-nearest neighbours (k-nn). We will first focus on prediction in cases where there is a response variable of interest and a predictor variable. We will work an example of multiple regression in the prediction context using k-nn. 8.2 Chapter learning objectives By the end of the chapter, students will be able to: Recognize situations where a simple regression analysis would be appropriate for making predictions. Explain the k-nearest neighbour (k-nn) regression algorithm and describe how it differs from k-nn classification. Interpret the output of a k-nn regression. In a dataset with two variables, perform k-nearest neighbour regression in R using caret::train() to predict the values for a test dataset. Using R, execute cross-validation in R to choose the number of neighbours. Using R, evaluate k-nn regression prediction accuracy using a test data set and an appropriate metric (e.g., root means square prediction error). In a dataset with &gt; 2 variables, perform k-nn regression in R using caret’s train with method = &quot;k-nn&quot; to predict the values for a test dataset. In the context of k-nn regression, compare and contrast goodness of fit and prediction properties (namely RMSE vs RMSPE). Describe advantages and disadvantages of the k-nearest neighbour regression approach. 8.3 Regression We can use regression as a method to answer a very similar question to classification (can we use past information to predict future observations?), but in the case of regression the goal is to predict numerical values instead of class labels. An example regression prediction question would be: can we use hours spent on exercise each week to predict marathon race time? And another example regression prediction question is: can we use house size (livable square feet) to predict house sale price? We will use regression to explore this question in the rest of this chapter, using a real estate data set from Sacremento, California that is available in the caret package. Note: in addition to prediction, regression can also be used to model the relationship between two or more variables, but here we will focus only on prediction. 8.4 Sacremento real estate example Let’s start by loading the libraries we need and previewing the data set. The data set comes with the caret package, so as soon as we load the caret library and type data(Sacramento) we are able to access it as a data frame named Sacramento. library(tidyverse) library(scales) library(caret) library(gridExtra) data(Sacramento) head(Sacramento) ## city zip beds baths sqft type price latitude longitude ## 1 SACRAMENTO z95838 2 1 836 Residential 59222 38.63191 -121.4349 ## 2 SACRAMENTO z95823 3 1 1167 Residential 68212 38.47890 -121.4310 ## 3 SACRAMENTO z95815 2 1 796 Residential 68880 38.61830 -121.4438 ## 4 SACRAMENTO z95815 2 1 852 Residential 69307 38.61684 -121.4391 ## 5 SACRAMENTO z95824 2 1 797 Residential 81900 38.51947 -121.4358 ## 6 SACRAMENTO z95841 3 1 1122 Condo 89921 38.66260 -121.3278 Given that we are interested in answering the question of if we can we use house size (livable square feet) to predict house sale price in the Sacremento, CA area; the columns in this data frame that we are interested in are sqft (which is the house size in livable square feet) and price, which is the house size in US dollars (USD). Let’s next visualize the data as a scatter plot where we place the predictor/explanatory variable, house size, on the x-axis and the target/response variable, price, on the y-axis (this is what we would like to predict): eda &lt;- ggplot(Sacramento, aes(x = sqft, y = price)) + geom_point(alpha = 0.4) + xlab(&quot;House size (square footage)&quot;) + ylab(&quot;Price (USD)&quot;) + scale_y_continuous(labels = dollar_format()) eda From looking at the visualization above, we see that in Sacramento, CA, as house size (square footage) increases, so does house price. Thus, we can reason that house size might be a useful predictor of house price and perhaps we can use the size of the house to predict the price a house will be sold at in this area (for a home that has not yet sold and thus consequently we do not know the house price). 8.5 K-nearest neighbours regression Let’s take a small sample of the data above and walk through how K-nearest neighbours (knn) regression works before we dive in to creating our model and assessing how well it predicts house price. This subsample is taken to allow us to illustrate the mechanics of k-nn regression with a few data points, later in this chapter we will use all the data. To take a small random sample of size 30 , we’ll use the function sample_n. This function takes two arguments: tbl (a data frame-like object to sample from) size (the number of observations/rows to be randomly selected/sampled) set.seed(1234) small_sacramento &lt;- sample_n(Sacramento, size = 30) Next let’s say we come across a new house we are interested in purchasing, and it is 2000 square feet! Its advertised list price is $350,000 should we offer to pay the asking price for this house? Or is that overpriced and we should offer less? Perhaps we cannot directly answer that, but we can get close by using the data we have to predict the sale price given the sale prices we have already observed. Given the data in the plot below, we have no observations of a house that has sold that is 2000 square feet, so how can we predict the price? small_plot &lt;- ggplot(small_sacramento, aes(x = sqft, y = price)) + geom_point() + xlab(&quot;House size (square footage)&quot;) + ylab(&quot;Price (USD)&quot;) + scale_y_continuous(labels=dollar_format()) + geom_vline(xintercept = 2000, linetype = &quot;dotted&quot;) small_plot What we can do is use the neighbouring points to suggest/predict what the price should be. For the example above, below we find and label the 5 nearest neighbours to our observation of a house that is 2000 square feet: nearest_neighbours &lt;- small_sacramento %&gt;% mutate(diff = abs(2000 - sqft)) %&gt;% arrange(diff) %&gt;% head(5) nearest_neighbours ## city zip beds baths sqft type price latitude ## 1 GOLD_RIVER z95670 3 2 1981 Residential 305000 38.62873 ## 2 ELK_GROVE z95758 4 2 2056 Residential 275000 38.41152 ## 3 ELK_GROVE z95624 5 3 2136 Residential 223058 38.43544 ## 4 RANCHO_CORDOVA z95742 4 2 1713 Residential 263500 38.55387 ## 5 RIO_LINDA z95673 2 2 1690 Residential 136500 38.69110 ## longitude diff ## 1 -121.2611 19 ## 2 -121.4814 56 ## 3 -121.3945 136 ## 4 -121.2191 287 ## 5 -121.4518 310 Now that we have the 5 nearest neighbours to our new observation that we would like to predict the price for, we can use their values to predict a selling price for the home we are interested in buying that is 2000 square feet. Specifically, we can take the mean (or average) of these 5 values as our predicted value. prediction &lt;- nearest_neighbours %&gt;% summarise(predicted = mean(price)) prediction ## predicted ## 1 240611.6 Our predicted price is $240612 (shown as a red point above), which is much less than $350,000, and so perhaps we might want to offer less than the list price that the house is advertised at. Simple right? Not quite. We have all the same unanswered questions here with k-nn regression that we had with k-nn classification. Which \\(k\\) do we choose? And, is our model any good at making predictions? We’ll shortly address how to answer these questions in the context of k-nn regression. 8.6 Assessing a knn regression model As usual, we should start by putting some test data away in a lock box that we can come back to after we choose our final model, so let’s take care of that business now. Note: for the remainder of the chapter we’ll be working with the entire Sacramento data set as opposed to the smaller sample of 30 points we worked with above. set.seed(1234) training_rows &lt;- Sacramento %&gt;% select(price) %&gt;% unlist() %&gt;% createDataPartition(p = 0.6, list = FALSE) X_train &lt;- Sacramento %&gt;% select(sqft) %&gt;% slice(training_rows) %&gt;% data.frame() Y_train &lt;- Sacramento %&gt;% select(price) %&gt;% slice(training_rows) %&gt;% unlist() X_test &lt;- Sacramento %&gt;% select(sqft) %&gt;% slice(-training_rows) %&gt;% data.frame() Y_test &lt;- Sacramento %&gt;% select(price) %&gt;% slice(-training_rows) %&gt;% unlist() Next, we’ll use cross-validation to choose \\(k\\). In k-nn classification, we used accuracy to see how well our predictions matched the true labels. Here in the context of k-nn regression we will use root mean square prediction error (\\(RMSPE\\)) instead. If the predictions are very close to the true values, then \\(RMSPE\\) will be small. If, on the other-hand, the predictions are very different to the true values, then \\(RMSPE\\) will be quite large. Thus, when we are doing cross validation to choose \\(k\\), we want to choose the \\(k\\) that gives us the smallest \\(RMSPE\\). The mathematical formula for calculating \\(RMSPE\\) is shown below: \\[RMSPE = \\sqrt{\\frac{1}{n}\\sum\\limits_{i=1}^{n}(y_i - \\hat{y_i})^2}\\] Where: \\(n\\) is the number of observations \\(y_i\\) is the observed value for the \\(ith\\) observation \\(\\hat{y_i}\\) is the forcasted/predicted value for the \\(ith\\) observation A key feature the formula for RMSE is the distance between the observed target/response variable value, \\(y\\), and the prediction target/response variable value, \\(\\hat{y_i}\\), for each observation (from 1 to \\(i\\)). Now that we know how we can assess how well our model predicts a numerical value, let’s use R to perform cross-validation and to choose the optimal \\(k\\). train_control &lt;- trainControl(method = &quot;cv&quot;, number = 10) # makes a column of k&#39;s, from 1 to 500 in increments of 5 k_lots = data.frame(k = seq(from = 1, to = 500, by = 5)) set.seed(1234) knn_reg_cv_10 &lt;- train(x = X_train, y = Y_train, method = &quot;knn&quot;, tuneGrid = k_lots, trControl = train_control) ggplot(knn_reg_cv_10$results, aes(x = k, y = RMSE)) + geom_point() + geom_line() Here we see that the smallest \\(RMSPE\\) is from the model where \\(k\\) = 41. Thus the best \\(k\\) for this model is 41. 8.6.1 \\(RMSPE\\) versus \\(RMSE\\) The error output we have been getting from caret to assess how well our k-nn regression models predict is labelled as RMSE, standing for root mean squared error. Why is this so? In statistics we try to be very precise with our language to indicate whether we are calculating the error on predicting on the training data (in sample prediction) versus predicting on the testing data (out of sample prediction). When we are predicting on the training data and we are interested in assessing model goodness of fit on the data used to fit the model, we say \\(RMSPE\\). Whereas when we are predicting on the testing data and we are trying to assess how well our model will do at predicting on future, unseen data (e.g., the validation set(s), or the testing set) we say \\(RMSPE\\). caret doesn’t really know what you are doing (using training or testing data for prediction) and so it just uses the term \\(RMSE\\) regardless. The equation for calculating \\(RMSE\\) and \\(RMSPE\\) is the same, all that changes is where the \\(y\\)’s come from. 8.7 How do different k’s affect k-nn regression predictions Below we plot the predicted values for house price from our k-nn regression models for 6 different values for \\(k\\) where the only predictor is home size. For each model, we predict a price for every possible home size across the range of home sizes we observed in the data set (here 500 to 4250 square feet) and we plot the predicted prices as a blue line: From the plots above, we see that when \\(k\\) = 1, the blue line runs perfectly through almost all of our training observations. This happens because our predicted values for a given region, depend on just a single observation. A model like this has high variance and low bias. It has high variance because the flexible blue line follows the training observations very closely, and if we were to change any one of the training observation data points we would change the flexible blue line quite a lot. This means that the blue line matches the data we happen to have in this training data set, however, if we were to collect another training data set from the Sacramento real estate market it likely wouldn’t match those observations as well. However, it has low bias because the model/predicted values matches the actual observed values in this training data set very well. Another term that we use to collectively describe this phenomenon is overfitting. What about the plot where \\(k\\) is quite large, say \\(k\\) = 450, for example? When \\(k\\) = 450 for this data set, the blue line is extremely smooth, and almost flat. This happens because our predicted values for a given x value (here home size), depend on many many neighbouring observations, 450 to be exact! A model like this has low variance and high bias. It has low variance because the smooth, inflexible blue line does not follow the training observations very closely, and if we were to change any one of the training observation data points it really wouldn’t affect the shape of the smooth blue line at all. This means that although the blue line matches does not match the data we happen to have in this particular training data set perfectly, if we were to collect another training data set from the Sacramento real estate market it likely would match those observations equally as well as it matches those in this training data set. This model also has high bias because the model/predicted values does not match the actual observed values very well. Another term that we use to collectively describe this kind of model is underfitting. Ideally, what we want is neither of the two examples discussed above. Instead, we would like a model with low variance (so that it will transer/generalize well to other data sets, meaning that it isn’t too dependent on the observations that happen to be in the training set we had) and low bias (one where the model/predicted values matches the actual observed values very well). If we explore the other values for \\(k\\), in particular \\(k\\) = 41 (the optimal \\(k\\) as suggested by cross-validation), we can see it has a lower bias than our model with a very high \\(k\\) (e.g., 450), and thus the model/predicted values better match the actual observed values than the high \\(k\\) model. Additionally, it has lower variance than our model with a very low \\(k\\) (e.g., 1) and thus it should better transer/generalize to other data sets compared to the low \\(k\\) model. All of this is similar to how the choice of \\(k\\) affects k-nn classification (discussed in the previous chapter). 8.8 Assessing how well the model predicts on unseen data with the test set To assess how well our model might do at predicting on unseen data, we will assess its RMSPE when predicting on the test data. Before we do that, we want to re-train our k-nn regression model on the entire training data set (not performing cross validation this time). In the case of k-nn regression we use the function defaultSummary instead of confusionMatrix (which we used with knn classification). This is because our predictions are not class labels, but values, and as such the type of model prediction performance score is calculated differently. defaultSummary expects a data frame where one column is the observed target/response variable values from the test data, and a second column of the predicted values for the test data. k = data.frame(k = knn_reg_cv_10$bestTune$k) set.seed(1234) knn_reg_final &lt;- train(x = X_train, y = Y_train, method = &quot;knn&quot;, tuneGrid = k) test_pred &lt;- predict(knn_reg_final, X_test) modelvalues &lt;- data.frame(obs = Y_test, pred = test_pred) test_results &lt;- defaultSummary(modelvalues) test_results ## RMSE Rsquared MAE ## 87120.618645 0.580151 64185.103589 Our final model’s test error as assessed by \\(RMSPE\\) is 87120.62. But what does this \\(RMSPE\\) score mean? When we calculated test set prediction accuracy when we performed k-nn classification the highest possible value was 1, and if we got an value close to that it was easy to assess how well our model did on at least one new data set that had never been used to choose our model (so we didn’t violate the golden rule of statistical/machine learning). So what about \\(RMSPE\\), what is it out of? Unfortunately there is no scale for \\(RMSPE\\) (instead it is measured in the units of the target/response variable), and so it is a bit hard to interpret. For now, let’s consider this approach to thinking about \\(RMSPE\\) from our testing data set: as long as its not WAY worse than the cross-validation \\(RMSPE\\) of our best model then we can say that we’re not doing too much worse on the test data than we did on the training data, and so it appears to be generalizing OK to a new data set it has never seen before. In future courses on statistical/machine learning we will learn more about how to interpret \\(RMSPE\\) from our testing data set and other ways to assess our model. And what does our final model look like when we predict across all possible house sizes we might encounter in the Sacramento area? We plotted it above where we explored how \\(k\\) affects k-nn regression, but we show it again now, along with the code for how we generated it: set.seed(1234) predictions_all &lt;- data.frame(sqft = seq(from = 500, to = 4250, by = 1)) predictions_all$price &lt;- predict(knn_reg_final, data.frame(sqft = seq(from = 500, to = 4250, by = 1))) train_data &lt;- bind_cols(X_train, data.frame(price = Y_train)) #combines X_train and Y_train to be on data set plot_final &lt;- ggplot(train_data, aes(x = sqft, y = price)) + geom_point(alpha = 0.4) + xlab(&quot;House size (square footage)&quot;) + ylab(&quot;Price (USD)&quot;) + scale_y_continuous(labels = dollar_format()) + geom_line(data = predictions_all, aes(x = sqft, y = price), color = &quot;blue&quot;) + ggtitle(&quot;k = 41&quot;) plot_final 8.9 Strengths and limitations of k-nn regression As with k-nn classification (or any prediction algorithm for that manner), k-nn regression has both strengths and weaknesses. Some are listed here: 8.9.1 Strengths of k-nn regression Simple and easy to understand No assumptions about what the data must look like Works well with non-linear relationships (i.e., if the relationship is not a straight line) 8.9.2 Limitations of k-nn regression As data gets bigger and bigger, k-nn gets slower and slower, quite quickly Does not perform well with a large number of predictors unless the size of the training set is exponentially larger Does not predict well beyond the range of values input in your training data 8.10 Multivariate k-nn regression As in k-nn classification, in k-nn regression we can have multiple predictors. When we have multiple predictors in k-nn regression, we have the same concern regarding the scale of the predictors. This is because as in k-nn classification and regression, predictions are made by identifying the \\(k\\) observations that are nearest to the new point we want to predict, and any variables that are on a large scale will have a much larger effect than variables on a small scale. Thus, once we start performing multivariate k-nn regression we need to use the scale function in R on our predictors to ensure this doesn’t happen. We will now demonstrate a multi-variate k-nn regression analysis again using the caret package on the Sacramento real estate data. This time we will use house size (measured in square feet) as well as number of bathrooms as our predictors, and continue to use house sale price as our outcome/target variable that we are trying to predict. It is always a good practice to do exploratory data analysis, such as visualizing the data, before we start modeling the data. Thus the first thing we will do is use ggpairs (from the GGally package) to plot all the variables we are interested in using in our analyses: library(GGally) plot_pairs &lt;- Sacramento %&gt;% select(price, sqft, baths) %&gt;% ggpairs() plot_pairs From this we can see that generally, as both house size and number of bathrooms increase, so does price. Does adding the number of baths to our model improve our ability to predict house price? To answer that question, we will have to come up with the test error for a k-nn regression model using house size and number of baths, and then we can compare it to the test error for the model we previously came up with that only used house size to see if it is smaller (decreased test error indicates increased prediction quality). Let’s do that now! Looking at the data above, we can see that sqft and beds (number of bedrooms) are on vastly different scales. Thus we need to apply the scale function to these columns before we start our analysis: scaled_Sacramento &lt;- Sacramento %&gt;% select(price, sqft, baths) %&gt;% mutate(sqft = scale(sqft, center = FALSE), baths = scale(baths, center = FALSE)) head(scaled_Sacramento) ## price sqft baths ## 1 59222 0.4564854 0.459221 ## 2 68212 0.6372231 0.459221 ## 3 68880 0.4346440 0.459221 ## 4 69307 0.4652220 0.459221 ## 5 81900 0.4351901 0.459221 ## 6 89921 0.6126515 0.459221 Now we can split our data into a trained and test set as we did before: set.seed(2019) # makes the random selection of rows reproducible training_rows &lt;- scaled_Sacramento %&gt;% select(price) %&gt;% unlist() %&gt;% # converts Class from a tibble to a vector createDataPartition(p = 0.6, list = FALSE) X_train &lt;- scaled_Sacramento %&gt;% select(sqft, baths) %&gt;% slice(training_rows) %&gt;% data.frame() Y_train &lt;- scaled_Sacramento %&gt;% select(price) %&gt;% slice(training_rows) %&gt;% unlist() X_test &lt;- scaled_Sacramento %&gt;% select(sqft, baths) %&gt;% slice(-training_rows) %&gt;% data.frame() Y_test &lt;- scaled_Sacramento %&gt;% select(price) %&gt;% slice(-training_rows) %&gt;% unlist() Next, we’ll use 10-fold cross-validation to choose \\(k\\): train_control &lt;- trainControl(method = &quot;cv&quot;, number = 10) # makes a column of k&#39;s, from 1 to 500 in increments of 5 k_lots = data.frame(k = seq(from = 1, to = 500, by = 5)) set.seed(1234) knn_reg_cv_10 &lt;- train(x = X_train, y = Y_train, method = &quot;knn&quot;, tuneGrid = k_lots, trControl = train_control) ggplot(knn_reg_cv_10$results, aes(x = k, y = RMSE)) + geom_point() + geom_line() Here we see that the smallest \\(RMSPE\\) is from the model where \\(k\\) = 36. Thus the best \\(k\\) for this model, with two predictors, is 36. Now that we have chosen \\(k\\), we need to re-train the model on the entire training data set with \\(k\\) = 36, and after that we can use that model to predict on the test data to get our test error. At that point we will also visualize the model predictions overlaid on top of the data. This time the predictions will be a plane in 3-D space, instead of a line in 2-D space, as we have 2 predictors instead of 3. k = data.frame(k = 36) set.seed(1234) knn_mult_reg_final &lt;- train(x = X_train, y = Y_train, method = &quot;knn&quot;, tuneGrid = k) test_pred &lt;- predict(knn_mult_reg_final, X_test) modelvalues &lt;- data.frame(obs = Y_test, pred = test_pred) knn_mult_test_results &lt;- defaultSummary(modelvalues) knn_mult_test_results[[1]] ## [1] 88906.27 This time when we performed k-nn regression on the same data set, but also included number of bathrooms as a predictor we obtained a \\(RMSPE\\) test error of 88906.27. This compares to a RMSPE test error of 87120.62 when we used only house size as the single predictor. Thus in this case, we did not improve the model by adding this additional predictor. What do the predictions from this model look like overlaid on the data? We can see that the predictions in this case, where we have 2 predictors, form a plane instead of a line. Because the newly added predictor, number of bathrooms, is correlated with price (USD) (meaning as price changes, so does number of bathrooms) we get additional and useful information for making our predictions. For example, in this model we would predict that the cost of a house with a scaled house size of ~ 0.52 and a scaled number bathrooms of ~ 1.13 would cost less than the same sized house with a higher scaled number bathrooms (e.g., ~ 2.11). Without having the additional predictor of number of bathrooms, we would predict the same price for these two houses. "],
["regression2.html", "Chapter 9 Regression, continued 9.1 Overview 9.2 Chapter learning objectives 9.3 Linear regression 9.4 Linear regression in R using caret 9.5 Comparing linear and k-nn regression 9.6 Multivariate linear regression 9.7 The other side of regression 9.8 Additional readings/resources", " Chapter 9 Regression, continued 9.1 Overview Introduction to linear regression models. We will also begin to compare k-nn to linear models in the context of regression. 9.2 Chapter learning objectives By the end of the chapter, students will be able to: In a dataset with 2 variables, perform simple ordinary least squares regression in R using caret’s train with method = &quot;lm&quot; to predict the values for a test dataset. Compare and contrast predictions obtained from k-nearest neighbour regression to those obtained using simple ordinary least squares regression from the same dataset. In R, overlay the ordinary least squares regression lines from geom_smooth on a single plot. 9.3 Linear regression k-nn is not the only type of regression, there are many, and one common and quite useful type of regression is called linear regression. Linear regression is similar to k-nn regression in that the target/response variable is expected to be quantitative, however, one way it varies quite differently is how the training data is used to predict a value for a new observation. Instead of looking at the \\(k\\)-nearest neighbours and averaging over their values for a prediction, in linear regression all the training data points are used to create a straight line of “best fit”, and then the line is used to “look-up” the predicted value. For example, let’s revisit the smaller version of the Sacramento housing data set and the prediction case where we come across a new house we are interested in purchasing, and it is 2000 square feet! Its advertised list price is $350,000 should we give them what they are asking? Or is that overpriced and we should offer less? To answer this question using linear regression, we use the data we have to draw the straight line of “best fit” through our existing data points: Then we can use this line to “look up” the predicted price given the value we have for the predictor/explanatory variable (here 2000 square feet). ## [1] 300750.5 Using linear regression on this small data set to predict the sale price for a 2000 square foot house we get a predicted value of $287178.80 USD. But wait a minute… How exactly does linear regression choose the line of “best fit”? Many different lines could be drawn through the data points, we show some examples below: Linear regression chooses the straight line of “best fit” by choosing the line that minimzes the average vertical distance between itself and each of the observed data points. From the lines shown above, that is the blue line. What exactly do we mean by the vertical distance between the predicted values (which fall along the line of “best fit”) and the observed data points? We illustrate these distances in the plot below with a red line: How do we assess the predictive accuracy of a linear regression model? We use the same measure of predictive performance we used with k-nn regression, \\(RMPSE\\) (note the use of \\(RMPSE\\) versus \\(RMSE\\) here as discussed in the first section of this chapter). 9.4 Linear regression in R using caret We can perform linear regression in R using the caret package in a very similar manner to how we performed k-nn regression, using the train function. To do this, instead of setting method = &quot;knn&quot; we instead set method = &quot;lm&quot;. Another difference is that we do not need to choose \\(k\\) in the context of linear regression and so we do not need to perform cross validation. Below we illustrate how we can use the caret package to predict house sale price given house size using a linear regression approach using the full Sacramento real estate data set: As usual, we should start by putting some test data away in a lock box that we can come back to after we choose our final model, so let’s take care of that business now. set.seed(2019) # makes the random selection of rows reproducible training_rows &lt;- Sacramento %&gt;% select(price) %&gt;% unlist() %&gt;% # converts Class from a tibble to a vector createDataPartition(p = 0.6, list = FALSE) X_train &lt;- Sacramento %&gt;% select(sqft) %&gt;% slice(training_rows) %&gt;% data.frame() Y_train &lt;- Sacramento %&gt;% select(price) %&gt;% slice(training_rows) %&gt;% unlist() X_test &lt;- Sacramento %&gt;% select(sqft) %&gt;% slice(-training_rows) %&gt;% data.frame() Y_test &lt;- Sacramento %&gt;% select(price) %&gt;% slice(-training_rows) %&gt;% unlist() Now that we have our training data, we fit our linear regression model: lm_model &lt;- train(x = X_train, y = Y_train, method = &quot;lm&quot;) And finally, we predict on the test data set to assess how well our model does: test_pred &lt;- predict(lm_model, X_test) lm_modelvalues &lt;- data.frame(obs = Y_test, pred = test_pred) lm_test_results &lt;- defaultSummary(lm_modelvalues) lm_test_results ## RMSE Rsquared MAE ## 8.510751e+04 6.002187e-01 6.305067e+04 Our final model’s test error as assessed by \\(RMSPE\\) is 86688.47. Remember that this is in units of the target/response variable, and here that is US Dollars (USD). Does this mean our model is “good” at predicting house sale price based off of the predictor of home size? Again answering this is tricky to answer and requires to use domain knowledge and think about the application you are using the prediction for. And what does our final linear regression model look like when we predict across all possible house sizes we might encounter in the Sacremento area? There is a plotting function in the tidyverse, geom_smooth, that allows us to do this easily by adding a layer on our plot with the linear regression predicted line of “best fit”. The default for this adds a plausible range to this line that we are not interested in at this point, so to avoid plotting it, we provide the argument se = FALSE in our call to geom_smooth. train_data &lt;- bind_cols(X_train, data.frame(price = Y_train)) lm_plot_final &lt;- ggplot(train_data, aes(x = sqft, y = price)) + geom_point(alpha = 0.4) + xlab(&quot;House size (square footage)&quot;) + ylab(&quot;Price (USD)&quot;) + scale_y_continuous(labels = dollar_format()) + geom_smooth(method = &quot;lm&quot;, se = FALSE) lm_plot_final 9.5 Comparing linear and k-nn regression Now that we have a general understanding of both linear and k-nn regression, we can start to compare and contrast these methods as well as the predictions made by them. To start, let’s look at the visualization of the linear regression model predictions for the Sacramento real estate data (predicting price from house size) and the “best” k-nn regression model obtained from the same problem: What differences do we observe from the visualization above? One obvious difference is the shape of the blue lines. In linear regression we are restricted to a straight line, whereas in k-nn regression our line is much more flexible and can be quite wiggly. There can be an advantage to limiting the model to a straight line, as linear regression does, in that a straight line model is quite interpretable and can be defined by two numbers, the y-intercept and the slope. The slope is particularly meaningful for interpretation, as it tells us what unit increase in the target/response variable we predict given a unit increase in the predictor/explanatory variable. Additionally, because our model is restricted to a straight line, we can even use the mathematical equation for a straight line as a basis to write a mathematical expression of our model. Remembering that the equation for a straight line is: \\[Y = \\beta_0 + \\beta_1X\\] Where: \\(\\beta_0\\) is the y-intercept of the line (the value where the line cuts the y-axis) \\(\\beta_1\\) is the slope of the line We can then write: \\[house\\: price = \\beta_0 + \\beta_1house\\: size\\] And finally, fill in the values for \\(\\beta_0\\) and \\(\\beta_1\\) from the straight line (we will show you how to get these from R next week) to get: \\[house\\: price = -64542.2 + 175.9*house\\: size\\] k-nn regression, as simple as it is to implement and understand, has no such interpretability from it’s wiggly line. There can however also be a disadvantage to using a linear regression model in some cases, particularly when the relationship between the target and the predictor is not linear, but instead some other shape, such as curved or circular. In these cases the prediction model from a linear regression will have high bias, meaning that model/predicted values does not match the actual observed values very well. Such a model would probably have a quite high \\(RMSE\\) when assessing model goodness of fit on the training data and a quite high \\(RMPSE\\) when assessing model prediction quality on a test data set. On such a data set, k-nn regression may fare better. Additionally, there are other types of regression you can learn about in future courses that may do even better at predicting with such data. How do these two models compare on this data set? On the visualizations above we also printed the \\(RMPSE\\) as calculated from predicting on the test data set that was not used to train/fit the models. The \\(RMPSE\\) for the linear regression model is less than the \\(RMPSE\\) for the k-nn regression model, and thus if were were comparing these in practice we would choose to use the linear regression model to make our predictions because of this (in addition to the fact the the linear regression model is more interpretable). 9.6 Multivariate linear regression As in k-nn classification and k-nn regression, in linear regression we can have multiple predictors. To do this, we follow a very similar approach to what we did using caret for k-nn regression, however, we do not need to use cross-validation to choose \\(k\\). We also do not need to scale the data for linear regression as it does not use a distance between points calculation in its algorithm. We demonstrate how to do this below using the Sacramento real estate data with both house size (measured in square feet) as well as number of bathrooms as our predictors, and continue to use house sale price as our outcome/target variable that we are trying to predict. We will start by splitting our data into a trained and test set as we did before: set.seed(2019) # makes the random selection of rows reproducible training_rows &lt;- Sacramento %&gt;% select(price) %&gt;% unlist() %&gt;% # converts Class from a tibble to a vector createDataPartition(p = 0.6, list = FALSE) lm_X_train &lt;- Sacramento %&gt;% select(sqft, baths) %&gt;% slice(training_rows) %&gt;% data.frame() lm_Y_train &lt;- Sacramento %&gt;% select(price) %&gt;% slice(training_rows) %&gt;% unlist() lm_X_test &lt;- Sacramento %&gt;% select(sqft, baths) %&gt;% slice(-training_rows) %&gt;% data.frame() lm_Y_test &lt;- Sacramento %&gt;% select(price) %&gt;% slice(-training_rows) %&gt;% unlist() Now we can fit the model on the training set using the method = &quot;lm&quot; argument in the train function: lm_mult_reg_final &lt;- train(x = lm_X_train, y = lm_Y_train, method = &quot;lm&quot;) What does our model predictions look like in the case of linear regression when we have two predictors? We illustrate this below: We see that the predictions from linear regression with two predictors form a plane as well, but this plane differs from the one we get from k-nn regression in its flexibility. The plane from k-nn regression above was more flexible and more closely followed the shape of the training data. The plane from linear regression however is constrained to being linear (i.e., a flat plane). As discussed this can be advantageous in one aspect, which is that for each predictor, we can get a slope from linear regression, and thus describe the plane mathematically. We can extract those slope values from our model object as shown below: lm_mult_reg_final$finalModel$coefficients ## (Intercept) sqft baths ## 8548.1070 134.4112 5888.5880 And then use those slopes, to write a mathematical equation to describe the prediction plane: Remembering that the equation for a plane is: \\[Y = \\beta_0 + \\beta_1X_1 + \\beta_2X_2\\] Where: \\(\\beta_0\\) is the y-intercept of the line (the value where the line cuts the y-axis) \\(\\beta_1\\) is the slope for the first predictor \\(X_1\\) is the first predictor \\(\\beta_2\\) is the slope for the second predictor \\(X_2\\) is the second predictor We can then write: \\[house\\: price = \\beta_0 + \\beta_1 \\:house\\: size + \\beta_2 \\:number\\: of \\: bathrooms\\] And finally, fill in the values for \\(\\beta_0\\), \\(\\beta_1\\) and \\(\\beta_2\\) from the model output above: \\[house\\: price = 25284.3344 + 140.2523*house\\: size -7115.9565 * \\:number\\: of \\: bathrooms\\] OK great, so this model is more interpretable than the multivariate k-nn regression model (i.e., we can write a mathematical equation that explains how each predictor is affecting the predictions), but as always, we should look at the test error and ask whether linear regression is doing a better job of predicting compared to k-nn regression in this multivariate regression case? To do that we can use this linear regression model to predict on the test data to get our test error. test_pred_lm &lt;- predict(lm_mult_reg_final, lm_X_test) lm_modelvalues &lt;- data.frame(obs = lm_Y_test, pred = test_pred_lm) lm_mult_test_results &lt;- defaultSummary(lm_modelvalues) lm_mult_test_results[[1]] ## [1] 85422.27 We get that the \\(RMSPE\\) for the multivariate linear regression model of 86778.87. This prediction error is less than the prediction error for the multivariate k-nn regression model, indicating that we should likely choose linear regression for predictions of house price on this data set. But wait, we should also ask if this more complex model is doing a better job of predicting compared to our simple linear regression model with only a single predictor (house size). Revisiting last chapter, we see that our \\(RMSPE\\) for our simple linear regression model with only a single predictor was 86688.47 which is less than that for our more complex model. Thus, again for interpretability sake as well as performance, we should in the end choose the simple linear regression model for this data set. Should we always end up choosing a simple linear regression as our model? No! And you never know what model will be the best until you go through this process. Exploratory data analysis can give you some hints, but until you look at the test error to compare the models you don’t really know. 9.7 The other side of regression So far in this textbook we have used regression only in the context of prediction, however, regression is also a powerful method to understand and/or describe the relationship between a quantitative outcome/response variable and one or more explanatory variables. Extending the case we have been working with in this chapter (where we are interested in house price as the outcome/response variable), we could also, or instead, be interested in describing the individual effects of house size and the number of bathrooms on house price, quantifying how big each of these effects are, and assessing how accurately we can estimate each of these effects. Using linear regression to answer such questions sits under the umbrella of statistical inference. Here we will only introduce this topic at a very high-level, but it is an important field that is widely used in Statistics and Data Science and is taught in many Statistical courses. In statistical inference we acknowledge that we can only measure some of all the possible observations that exist in the world for the thing we are interested in quantifying. And so what we do, is use the measurements that we do have to infer/make a guess about what the true quantity would be if we could measure every possible thing. One example of statistical inference would be to try to estimate/come up with a best guess to the proportion of undergraduates who have an iphone. We cannot possibly ask all existing undergraduates if they have an iphone, so what can we do? Well, what statistical inference suggests that instead of asking all undergraduates (which we cannot do), we instead ask a random (and representative) sample of undergraduates if they have an iphone. From this sample of data we calculate the proportion of undergraduates that have an iphone. We can then use this proportion as an estimate/best guess of the proportion of all undergradautes that have an iphone. We know the proportion we calculated is not exactly right, but we think it should be close and it’s the best we can do (since we cannot possibly ask all undergraduates and get the exact truth). Since we know that it’s not exaclty right, we also try to use the data we have collected to come up with a plausible range where we think the true proportion of all undergradautes that have an iphone lies. Now here in this chapter in the context of linear regression, we are not talking about estimating a proportion, instead we are instead usually interested in estimating the slope/coefficient of the relationship between the outcome/response variable and one or more predictor variables. Again, in this case, whatever we are measuring is usually just a sample of all the things we could measure. Here in this chapter it is a sample of observations measuring the sale and house characteristics of 932 (out of &gt; 180,000) homes in Sacramento. Fitting our linear model, we did come up with an estimate for the slope for the relationship between house sale price and home size as 175.9. We know this number is not the true slope for the relationship between these two variables, however this is the best guess/estimate we can come up with given the data that we have. The next step of regression in this statistical inference perspective would be to use the data we have come up with a plausible range for where we think the value for the true slope would lie. We will not go into the details of how to do this in this course, but this will be covered in following Statistics courses. However, if you are very interested we will say that boostrapping to generate confidence intervals would be one approach that would let you do this and we point you to the additional readings for this chapter to learn more if you are interested. 9.8 Additional readings/resources Pages 59-71 of Introduction to Statistical Learning with Applications in R by Gareth James, Daniela Witten, Trevor Hastie and Robert Tibshirani Pages 104 - 109 of An Introduction to Statistical Learning with Applications in R by Gareth James, Daniela Witten, Trevor Hastie and Robert Tibshirani The caret Package Chapters 6 - 11 of Modern Dive Statistical Inference via Data Science by Chester Ismay and Albert Y. Kim "],
["clustering.html", "Chapter 10 Clustering 10.1 Overview 10.2 Chapter learning objectives 10.3 Clustering 10.4 K-means clustering algorithm 10.5 K-means clustering in R 10.6 Choosing K for K-means clustering 10.7 Additional readings:", " Chapter 10 Clustering 10.1 Overview Introduction to clustering using K-means. Will discuss the K-means algorithm, how we choose K (the number of clusters) and other practical considerations (such as scaling). 10.2 Chapter learning objectives By the end of the chapter, students will be able to: Describe a case where clustering would be an appropriate tool, and what insight it would bring from the data. Explain the K-means clustering algorithm. Interpret the output of a K-means analysis. Perform kmeans clustering in R using kmeans. Visualize the output of K-means clustering in R using pair-wise scatter plots. Identify when it is necessary to scale variables before clustering and do this using R. Use the elbow method to choose the number of clusters for K-means. Describe advantages, limitations and assumptions of the K-means clustering algorithm. 10.3 Clustering While at first glance, clustering may seem very similar to classification, these two methods have some very important distinction. Most notably, classification is a supervised method (we use past information to predict the future values/labels for our target/response variable), whereas clustering is considered an unsupervised method (there is no target/response variable and we are looking to find sub-groups/clusters of observations based on how similar they are). So, where classification might be used to label future emails as spam or not spam, clustering might be instead be used to group emails into categories based on their similarity, however we would not have labels for these categories in the case of clustering. Another example problem we might try to solve with clustering is grouping Amazon customers into groups based upon their similar purchasing behaviours. Again here, we do not have, nor need, labels for customer groups. Another way to think about it is, that classification is really about predicting something that you might have a scientific question about and/or hypothesis for, whereas, clustering is very often a hypothesis generating process (you identify things that are similar to each other that might be unexpected, and from those observations, you might generate a question and hypothesis that you might follow-up with classification). Another major difference between clustering and classification is in how success is determined. With classification we are able to use a test data set to assess prediction performance, in clustering we must use variance metrics to determine how well our defined clusters fit the data. The two metrics used to determine success are between- and within- variation. Ideally we want clusters where the between-variance is large (so that the clusters are well separated) and the within- variation is small (so that the clusters are composed of close/tight-knit observations). 10.3.1 A toy example What if we had some customer data, and we wanted to learn more about the types of customers we had so that we could come up with better products and/or promotions to increase our business in a data-driven way. For example, let’s consider this data below, where we have assessed customer loyalty and customer satisfaction: data modified from: http://www.segmentationstudyguide.com/using-cluster-analysis-for-market-segmentation/ From this data we might ask whether there are sub-groups within our customers? For example do we have customers with high loyalty and high satisfaction? What about low satisfaction and high loyalty? One way to answer such a question is to apply K-means clustering analysis. When we do such an analysis on this data set we identify 3 customer subgroups within our data set: What are the labels for these groups? We don’t really have any, only cluster numbers are output from the clustering algorithm. In a simple case like this, where we can easily visualize the clusters on a scatter plot, we can give labels to these groups after clustering using the positions of the groups on the plot: low loyalty and low satisfaction (green cluster), high loyalty and low satisfaction (pink cluster), and high loyalty and high satisfaction (blue cluster). Once we have such data we can use it to inform our future business decisions, and/or ask questions like, why did we not observe customers who had high satisfaction but low loyalty? 10.4 K-means clustering algorithm Watch the video linked to below for an explanation of the K-means clustering algorithm: - https://www.coursera.org/lecture/machine-learning-data-analysis/what-is-a-k-means-cluster-analysis-p94tY note - when the advertisement pops up to register for this course, you can just click to ignore it (i.e., no need to sign up to watch the entire video) 10.5 K-means clustering in R Let’s take a look at the data we plotted above: head(marketing_data) ## # A tibble: 6 x 2 ## loyalty csat ## &lt;dbl&gt; &lt;dbl&gt; ## 1 7 1 ## 2 7.5 1 ## 3 8 2 ## 4 7 2 ## 5 3 2 ## 6 1 3 To peform Kmeans clustering in R, we use the kmeans function. It takes at least two arguments, the data frame containing the data you wish to cluster, and K, the number of clusters (here we choose K = 3). Given that the K-means algorithm uses a random start to begin the algorithm, to make this reproducible, we need to set the seed. set.seed(1234) marketing_clust &lt;- kmeans(marketing_data, centers = 3) marketing_clust ## K-means clustering with 3 clusters of sizes 2, 10, 7 ## ## Cluster means: ## loyalty csat ## 1 9.000000 8.500000 ## 2 4.950000 2.500000 ## 3 6.142857 7.142857 ## ## Clustering vector: ## [1] 2 2 2 2 2 2 2 2 2 3 3 3 3 3 1 3 1 3 2 ## ## Within cluster sum of squares by cluster: ## [1] 0.50000 81.72500 11.71429 ## (between_SS / total_SS = 61.0 %) ## ## Available components: ## ## [1] &quot;cluster&quot; &quot;centers&quot; &quot;totss&quot; &quot;withinss&quot; ## [5] &quot;tot.withinss&quot; &quot;betweenss&quot; &quot;size&quot; &quot;iter&quot; ## [9] &quot;ifault&quot; As you can see above, the clustering object returned has a lot of information about our analysis that we need to explore. Let’s take a look at it now. To do this, we will call in help from the broom package so that we get the model output back in a tidy data format. Let’s first start by getting the cluster identification for each point and plotting that on the scatter plot. To do that we use the augment function. Augment takes in the model and the original data frame, and returns a data frame with the data and the cluster assignments for each point: library(broom) clustered_data &lt;- augment(marketing_clust, marketing_data) head(clustered_data) ## # A tibble: 6 x 3 ## loyalty csat .cluster ## &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 7 1 2 ## 2 7.5 1 2 ## 3 8 2 2 ## 4 7 2 2 ## 5 3 2 2 ## 6 1 3 2 Now that we have this data frame, we can easily plot the data (i.e., cluster assignments of each point): cluster_plot &lt;- ggplot(clustered_data, aes(x = csat, y = loyalty, colour = .cluster)) + geom_point() cluster_plot 10.6 Choosing K for K-means clustering As mentioned above, we need to choose a K to perform K-means clustering. How should we choose K? We have no data labels, and so cannot perform cross-validation with some measure of model prediction error, so what can we do? What we can do in this situation is to look at the total within-cluster sum of squares for different K’s and choose the K that gives the biggest decrease in the total within-cluster sum of squares. Why total within-cluster sum of squares? This statistic lets us know how close/tight-knit (or compact) observations are within clusters. A larger number means that clusters are not close/tight-knit, but are instead more spread out. A smaller number here means that clusters are indeed close/tight-knit together. We can get at the total within-cluster sum of squares (tot.withinss) from our clustering using broom’s glance function (it gives model-level statistics). For example: glance(marketing_clust) ## # A tibble: 1 x 4 ## totss tot.withinss betweenss iter ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 241. 93.9 147. 2 Let’s calculate the total within-cluster sum of squares for our data for a variety of K’s (say 1 - 9) and then plot them against K. To do this we will create a data frame with a column named k, for each of the K’s we want to try our clustering with. Then we use map to apply the kmeans function to each K. We also use map to then apply glance to each of the clustering models we performed (one for each K). In the end we end up with a complex data frame with 3 columns, one for K, one for the models, and one for the model statistics (output of glance, which is a data frame): marketing_clust_ks &lt;- tibble(k = 1:9) %&gt;% mutate(marketing_clusts = map(k, ~kmeans(marketing_data, .x)), glanced = map(marketing_clusts, glance)) head(marketing_clust_ks) ## # A tibble: 6 x 3 ## k marketing_clusts glanced ## &lt;int&gt; &lt;list&gt; &lt;list&gt; ## 1 1 &lt;kmeans&gt; &lt;tibble [1 × 4]&gt; ## 2 2 &lt;kmeans&gt; &lt;tibble [1 × 4]&gt; ## 3 3 &lt;kmeans&gt; &lt;tibble [1 × 4]&gt; ## 4 4 &lt;kmeans&gt; &lt;tibble [1 × 4]&gt; ## 5 5 &lt;kmeans&gt; &lt;tibble [1 × 4]&gt; ## 6 6 &lt;kmeans&gt; &lt;tibble [1 × 4]&gt; What we need to do next, is get the value for the total within-cluster sum of squares (tot.withinss) from the glanced column. Given that each item in this column is a data frame, we will need to use the unnest function to unpack the data frames in the glanced column. clustering_statistics &lt;- marketing_clust_ks %&gt;% unnest(glanced) head(clustering_statistics) ## # A tibble: 6 x 6 ## k marketing_clusts totss tot.withinss betweenss iter ## &lt;int&gt; &lt;list&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 1 &lt;kmeans&gt; 241. 241. 0 1 ## 2 2 &lt;kmeans&gt; 241. 110. 132. 1 ## 3 3 &lt;kmeans&gt; 241. 39.6 202. 1 ## 4 4 &lt;kmeans&gt; 241. 24.0 217. 2 ## 5 5 &lt;kmeans&gt; 241. 19.8 221. 2 ## 6 6 &lt;kmeans&gt; 241. 15.8 225. 2 Now that we have tot.withinss and k as columns in a data frame, we can make a plot to choose K: elbow_plot &lt;- ggplot(clustering_statistics, aes(x = k, y = tot.withinss)) + geom_point() + geom_line() + xlab(&quot;K&quot;) + ylab(&quot;Total within-cluster sum of squares&quot;) elbow_plot We call the plot above an “elbow plot” and we look for the “elbow” in total within-cluster sum of squares, the point where afterwards increasing K doesn’t have as much impact reducing the total within-cluster sum of squares. Here we would choose K = 3. 10.7 Additional readings: Pages 385-390 and 404-405 of Introduction to Statistical Learning with Applications in R by Gareth James, Daniela Witten, Trevor Hastie and Robert Tibshirani and the companion video linked to below: "]
]
